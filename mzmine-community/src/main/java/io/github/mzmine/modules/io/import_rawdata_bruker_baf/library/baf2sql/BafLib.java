/*
 * Copyright (c) 2004-2024 The MZmine Development Team
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

// Generated by jextract

package io.github.mzmine.modules.io.import_rawdata_bruker_baf.library.baf2sql;

import static java.lang.foreign.ValueLayout.JAVA_BYTE;
import static java.lang.foreign.ValueLayout.OfByte;
import static java.lang.foreign.ValueLayout.OfInt;
import static java.lang.foreign.ValueLayout.OfLong;
import static java.lang.foreign.ValueLayout.OfShort;

import java.lang.foreign.AddressLayout;
import java.lang.foreign.Arena;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.GroupLayout;
import java.lang.foreign.Linker;
import java.lang.foreign.MemoryLayout;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.PaddingLayout;
import java.lang.foreign.SequenceLayout;
import java.lang.foreign.StructLayout;
import java.lang.foreign.SymbolLookup;
import java.lang.foreign.ValueLayout;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.net.URISyntaxException;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.stream.Collectors;

public class BafLib {

  BafLib() {
    // Should not be called directly
  }

  static final Arena LIBRARY_ARENA = Arena.ofAuto();
  static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

  static void traceDowncall(String name, Object... args) {
    String traceArgs = Arrays.stream(args).map(Object::toString).collect(Collectors.joining(", "));
    System.out.printf("%s(%s)\n", name, traceArgs);
  }

  static MemorySegment findOrThrow(String symbol) {
    return SYMBOL_LOOKUP.find(symbol)
        .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
  }

  static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
    try {
      return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
    } catch (ReflectiveOperationException ex) {
      throw new AssertionError(ex);
    }
  }

  static MemoryLayout align(MemoryLayout layout, long align) {
    return switch (layout) {
      case PaddingLayout p -> p;
      case ValueLayout v -> v.withByteAlignment(align);
      case GroupLayout g -> {
        MemoryLayout[] alignedMembers = g.memberLayouts().stream().map(m -> align(m, align))
            .toArray(MemoryLayout[]::new);
        yield g instanceof StructLayout ? MemoryLayout.structLayout(alignedMembers)
            : MemoryLayout.unionLayout(alignedMembers);
      }
      case SequenceLayout s ->
          MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
    };
  }

//  static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(
//          BafLib.class.getClassLoader().getResource("vendorlib/bruker_baf/%s".formatted(LIB_NAME.get()))
//              .toString(), LIBRARY_ARENA).or(SymbolLookup.loaderLookup())
//      .or(Linker.nativeLinker().defaultLookup());
//static final String path = System.mapLibraryName(
//    "C:\\Users\\Steffen\\git\\mzmine3\\mzmine-community\\src\\main\\resources\\vendorlib\\bruker_baf\\baf2sql_c");

  // not nice but the only thing that would work properly
  static final Path path;
  static {
    try {
      path = Path.of(BafLib.class.getClassLoader()
          .getResource("vendorlib/bruker_baf/%s".formatted(System.mapLibraryName("baf2sql_c")))
          .toURI());
    } catch (URISyntaxException e) {
      throw new RuntimeException(e);
    }
  }

  static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(path, LIBRARY_ARENA)
      .or(SymbolLookup.loaderLookup()).or(Linker.nativeLinker().defaultLookup());

  public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
  public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
  public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
  public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
  public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
  public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
  public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
  public static final AddressLayout C_POINTER = ValueLayout.ADDRESS.withTargetLayout(
      MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
  public static final ValueLayout.OfInt C_LONG = ValueLayout.JAVA_INT;
  public static final ValueLayout.OfDouble C_LONG_DOUBLE = ValueLayout.JAVA_DOUBLE;
  /**
   * {@snippet lang = c:
   * typedef long long int64_t
   *}
   */
  public static final OfLong int64_t = BafLib.C_LONG_LONG;
  /**
   * {@snippet lang = c:
   * typedef unsigned long long uint64_t
   *}
   */
  public static final OfLong uint64_t = BafLib.C_LONG_LONG;
  /**
   * {@snippet lang = c:
   * typedef int64_t int_least64_t
   *}
   */
  public static final OfLong int_least64_t = BafLib.C_LONG_LONG;
  /**
   * {@snippet lang = c:
   * typedef uint64_t uint_least64_t
   *}
   */
  public static final OfLong uint_least64_t = BafLib.C_LONG_LONG;
  /**
   * {@snippet lang = c:
   * typedef int64_t int_fast64_t
   *}
   */
  public static final OfLong int_fast64_t = BafLib.C_LONG_LONG;
  /**
   * {@snippet lang = c:
   * typedef uint64_t uint_fast64_t
   *}
   */
  public static final OfLong uint_fast64_t = BafLib.C_LONG_LONG;
  /**
   * {@snippet lang = c:
   * typedef int int32_t
   *}
   */
  public static final OfInt int32_t = BafLib.C_INT;
  /**
   * {@snippet lang = c:
   * typedef unsigned int uint32_t
   *}
   */
  public static final OfInt uint32_t = BafLib.C_INT;
  /**
   * {@snippet lang = c:
   * typedef int32_t int_least32_t
   *}
   */
  public static final OfInt int_least32_t = BafLib.C_INT;
  /**
   * {@snippet lang = c:
   * typedef uint32_t uint_least32_t
   *}
   */
  public static final OfInt uint_least32_t = BafLib.C_INT;
  /**
   * {@snippet lang = c:
   * typedef int32_t int_fast32_t
   *}
   */
  public static final OfInt int_fast32_t = BafLib.C_INT;
  /**
   * {@snippet lang = c:
   * typedef uint32_t uint_fast32_t
   *}
   */
  public static final OfInt uint_fast32_t = BafLib.C_INT;
  /**
   * {@snippet lang = c:
   * typedef short int16_t
   *}
   */
  public static final OfShort int16_t = BafLib.C_SHORT;
  /**
   * {@snippet lang = c:
   * typedef unsigned short uint16_t
   *}
   */
  public static final OfShort uint16_t = BafLib.C_SHORT;
  /**
   * {@snippet lang = c:
   * typedef int16_t int_least16_t
   *}
   */
  public static final OfShort int_least16_t = BafLib.C_SHORT;
  /**
   * {@snippet lang = c:
   * typedef uint16_t uint_least16_t
   *}
   */
  public static final OfShort uint_least16_t = BafLib.C_SHORT;
  /**
   * {@snippet lang = c:
   * typedef int16_t int_fast16_t
   *}
   */
  public static final OfShort int_fast16_t = BafLib.C_SHORT;
  /**
   * {@snippet lang = c:
   * typedef uint16_t uint_fast16_t
   *}
   */
  public static final OfShort uint_fast16_t = BafLib.C_SHORT;
  /**
   * {@snippet lang = c:
   * typedef signed char int8_t
   *}
   */
  public static final OfByte int8_t = BafLib.C_CHAR;
  /**
   * {@snippet lang = c:
   * typedef unsigned char uint8_t
   *}
   */
  public static final OfByte uint8_t = BafLib.C_CHAR;
  /**
   * {@snippet lang = c:
   * typedef int8_t int_least8_t
   *}
   */
  public static final OfByte int_least8_t = BafLib.C_CHAR;
  /**
   * {@snippet lang = c:
   * typedef uint8_t uint_least8_t
   *}
   */
  public static final OfByte uint_least8_t = BafLib.C_CHAR;
  /**
   * {@snippet lang = c:
   * typedef int8_t int_fast8_t
   *}
   */
  public static final OfByte int_fast8_t = BafLib.C_CHAR;
  /**
   * {@snippet lang = c:
   * typedef uint8_t uint_fast8_t
   *}
   */
  public static final OfByte uint_fast8_t = BafLib.C_CHAR;
  /**
   * {@snippet lang = c:
   * typedef long long intptr_t
   *}
   */
  public static final OfLong intptr_t = BafLib.C_LONG_LONG;
  /**
   * {@snippet lang = c:
   * typedef unsigned long long uintptr_t
   *}
   */
  public static final OfLong uintptr_t = BafLib.C_LONG_LONG;
  /**
   * {@snippet lang = c:
   * typedef long long intmax_t
   *}
   */
  public static final OfLong intmax_t = BafLib.C_LONG_LONG;
  /**
   * {@snippet lang = c:
   * typedef unsigned long long uintmax_t
   *}
   */
  public static final OfLong uintmax_t = BafLib.C_LONG_LONG;

  private static class baf2sql_get_sqlite_cache_filename {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(BafLib.C_INT,
        BafLib.C_POINTER, BafLib.C_INT, BafLib.C_POINTER);

    public static final MemorySegment ADDR = BafLib.findOrThrow(
        "baf2sql_get_sqlite_cache_filename");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t baf2sql_get_sqlite_cache_filename(char *sql_filename_buf, uint32_t sql_filename_buflen, const char *baf_filename)
   *}
   */
  public static FunctionDescriptor baf2sql_get_sqlite_cache_filename$descriptor() {
    return baf2sql_get_sqlite_cache_filename.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t baf2sql_get_sqlite_cache_filename(char *sql_filename_buf, uint32_t sql_filename_buflen, const char *baf_filename)
   *}
   */
  public static MethodHandle baf2sql_get_sqlite_cache_filename$handle() {
    return baf2sql_get_sqlite_cache_filename.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t baf2sql_get_sqlite_cache_filename(char *sql_filename_buf, uint32_t sql_filename_buflen, const char *baf_filename)
   *}
   */
  public static MemorySegment baf2sql_get_sqlite_cache_filename$address() {
    return baf2sql_get_sqlite_cache_filename.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t baf2sql_get_sqlite_cache_filename(char *sql_filename_buf, uint32_t sql_filename_buflen, const char *baf_filename)
   *}
   */
  public static int baf2sql_get_sqlite_cache_filename(MemorySegment sql_filename_buf,
      int sql_filename_buflen, MemorySegment baf_filename) {
    var mh$ = baf2sql_get_sqlite_cache_filename.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("baf2sql_get_sqlite_cache_filename", sql_filename_buf, sql_filename_buflen,
            baf_filename);
      }
      return (int) mh$.invokeExact(sql_filename_buf, sql_filename_buflen, baf_filename);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  private static class baf2sql_get_sqlite_cache_filename_v2 {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(BafLib.C_INT,
        BafLib.C_POINTER, BafLib.C_INT, BafLib.C_POINTER, BafLib.C_INT);

    public static final MemorySegment ADDR = BafLib.findOrThrow(
        "baf2sql_get_sqlite_cache_filename_v2");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t baf2sql_get_sqlite_cache_filename_v2(char *sql_filename_buf, uint32_t sql_filename_buflen, const char *baf_filename, int translate_all_baf_variables)
   *}
   */
  public static FunctionDescriptor baf2sql_get_sqlite_cache_filename_v2$descriptor() {
    return baf2sql_get_sqlite_cache_filename_v2.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t baf2sql_get_sqlite_cache_filename_v2(char *sql_filename_buf, uint32_t sql_filename_buflen, const char *baf_filename, int translate_all_baf_variables)
   *}
   */
  public static MethodHandle baf2sql_get_sqlite_cache_filename_v2$handle() {
    return baf2sql_get_sqlite_cache_filename_v2.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t baf2sql_get_sqlite_cache_filename_v2(char *sql_filename_buf, uint32_t sql_filename_buflen, const char *baf_filename, int translate_all_baf_variables)
   *}
   */
  public static MemorySegment baf2sql_get_sqlite_cache_filename_v2$address() {
    return baf2sql_get_sqlite_cache_filename_v2.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t baf2sql_get_sqlite_cache_filename_v2(char *sql_filename_buf, uint32_t sql_filename_buflen, const char *baf_filename, int translate_all_baf_variables)
   *}
   */
  public static int baf2sql_get_sqlite_cache_filename_v2(MemorySegment sql_filename_buf,
      int sql_filename_buflen, MemorySegment baf_filename, int translate_all_baf_variables) {
    var mh$ = baf2sql_get_sqlite_cache_filename_v2.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("baf2sql_get_sqlite_cache_filename_v2", sql_filename_buf, sql_filename_buflen,
            baf_filename, translate_all_baf_variables);
      }
      return (int) mh$.invokeExact(sql_filename_buf, sql_filename_buflen, baf_filename,
          translate_all_baf_variables);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  private static class baf2sql_array_open_storage {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(BafLib.C_LONG_LONG,
        BafLib.C_INT, BafLib.C_POINTER);

    public static final MemorySegment ADDR = BafLib.findOrThrow("baf2sql_array_open_storage");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint64_t baf2sql_array_open_storage(int raw_calibration, const char *baf_filename)
   *}
   */
  public static FunctionDescriptor baf2sql_array_open_storage$descriptor() {
    return baf2sql_array_open_storage.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint64_t baf2sql_array_open_storage(int raw_calibration, const char *baf_filename)
   *}
   */
  public static MethodHandle baf2sql_array_open_storage$handle() {
    return baf2sql_array_open_storage.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint64_t baf2sql_array_open_storage(int raw_calibration, const char *baf_filename)
   *}
   */
  public static MemorySegment baf2sql_array_open_storage$address() {
    return baf2sql_array_open_storage.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint64_t baf2sql_array_open_storage(int raw_calibration, const char *baf_filename)
   *}
   */
  public static long baf2sql_array_open_storage(int raw_calibration, MemorySegment baf_filename) {
    var mh$ = baf2sql_array_open_storage.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("baf2sql_array_open_storage", raw_calibration, baf_filename);
      }
      return (long) mh$.invokeExact(raw_calibration, baf_filename);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  private static class baf2sql_array_get_num_elements {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(BafLib.C_INT,
        BafLib.C_LONG_LONG, BafLib.C_LONG_LONG, BafLib.C_POINTER);

    public static final MemorySegment ADDR = BafLib.findOrThrow("baf2sql_array_get_num_elements");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * int baf2sql_array_get_num_elements(uint64_t handle, uint64_t id, uint64_t *num_elements)
   *}
   */
  public static FunctionDescriptor baf2sql_array_get_num_elements$descriptor() {
    return baf2sql_array_get_num_elements.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * int baf2sql_array_get_num_elements(uint64_t handle, uint64_t id, uint64_t *num_elements)
   *}
   */
  public static MethodHandle baf2sql_array_get_num_elements$handle() {
    return baf2sql_array_get_num_elements.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * int baf2sql_array_get_num_elements(uint64_t handle, uint64_t id, uint64_t *num_elements)
   *}
   */
  public static MemorySegment baf2sql_array_get_num_elements$address() {
    return baf2sql_array_get_num_elements.ADDR;
  }

  /**
   * {@snippet lang = c:
   * int baf2sql_array_get_num_elements(uint64_t handle, uint64_t id, uint64_t *num_elements)
   *}
   */
  public static int baf2sql_array_get_num_elements(long handle, long id,
      MemorySegment num_elements) {
    var mh$ = baf2sql_array_get_num_elements.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("baf2sql_array_get_num_elements", handle, id, num_elements);
      }
      return (int) mh$.invokeExact(handle, id, num_elements);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  private static class baf2sql_array_read_double {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(BafLib.C_INT,
        BafLib.C_LONG_LONG, BafLib.C_LONG_LONG, BafLib.C_POINTER);

    public static final MemorySegment ADDR = BafLib.findOrThrow("baf2sql_array_read_double");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * int baf2sql_array_read_double(uint64_t handle, uint64_t id, double buf[])
   *}
   */
  public static FunctionDescriptor baf2sql_array_read_double$descriptor() {
    return baf2sql_array_read_double.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * int baf2sql_array_read_double(uint64_t handle, uint64_t id, double buf[])
   *}
   */
  public static MethodHandle baf2sql_array_read_double$handle() {
    return baf2sql_array_read_double.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * int baf2sql_array_read_double(uint64_t handle, uint64_t id, double buf[])
   *}
   */
  public static MemorySegment baf2sql_array_read_double$address() {
    return baf2sql_array_read_double.ADDR;
  }

  /**
   * {@snippet lang = c:
   * int baf2sql_array_read_double(uint64_t handle, uint64_t id, double buf[])
   *}
   */
  public static int baf2sql_array_read_double(long handle, long id, MemorySegment buf) {
    var mh$ = baf2sql_array_read_double.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("baf2sql_array_read_double", handle, id, buf);
      }
      return (int) mh$.invokeExact(handle, id, buf);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  private static class baf2sql_array_read_float {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(BafLib.C_INT,
        BafLib.C_LONG_LONG, BafLib.C_LONG_LONG, BafLib.C_POINTER);

    public static final MemorySegment ADDR = BafLib.findOrThrow("baf2sql_array_read_float");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * int baf2sql_array_read_float(uint64_t handle, uint64_t id, float buf[])
   *}
   */
  public static FunctionDescriptor baf2sql_array_read_float$descriptor() {
    return baf2sql_array_read_float.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * int baf2sql_array_read_float(uint64_t handle, uint64_t id, float buf[])
   *}
   */
  public static MethodHandle baf2sql_array_read_float$handle() {
    return baf2sql_array_read_float.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * int baf2sql_array_read_float(uint64_t handle, uint64_t id, float buf[])
   *}
   */
  public static MemorySegment baf2sql_array_read_float$address() {
    return baf2sql_array_read_float.ADDR;
  }

  /**
   * {@snippet lang = c:
   * int baf2sql_array_read_float(uint64_t handle, uint64_t id, float buf[])
   *}
   */
  public static int baf2sql_array_read_float(long handle, long id, MemorySegment buf) {
    var mh$ = baf2sql_array_read_float.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("baf2sql_array_read_float", handle, id, buf);
      }
      return (int) mh$.invokeExact(handle, id, buf);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  private static class baf2sql_array_read_uint32 {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(BafLib.C_INT,
        BafLib.C_LONG_LONG, BafLib.C_LONG_LONG, BafLib.C_POINTER);

    public static final MemorySegment ADDR = BafLib.findOrThrow("baf2sql_array_read_uint32");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * int baf2sql_array_read_uint32(uint64_t handle, uint64_t id, uint32_t buf[])
   *}
   */
  public static FunctionDescriptor baf2sql_array_read_uint32$descriptor() {
    return baf2sql_array_read_uint32.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * int baf2sql_array_read_uint32(uint64_t handle, uint64_t id, uint32_t buf[])
   *}
   */
  public static MethodHandle baf2sql_array_read_uint32$handle() {
    return baf2sql_array_read_uint32.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * int baf2sql_array_read_uint32(uint64_t handle, uint64_t id, uint32_t buf[])
   *}
   */
  public static MemorySegment baf2sql_array_read_uint32$address() {
    return baf2sql_array_read_uint32.ADDR;
  }

  /**
   * {@snippet lang = c:
   * int baf2sql_array_read_uint32(uint64_t handle, uint64_t id, uint32_t buf[])
   *}
   */
  public static int baf2sql_array_read_uint32(long handle, long id, MemorySegment buf) {
    var mh$ = baf2sql_array_read_uint32.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("baf2sql_array_read_uint32", handle, id, buf);
      }
      return (int) mh$.invokeExact(handle, id, buf);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  private static class baf2sql_array_close_storage {

    public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(BafLib.C_LONG_LONG);

    public static final MemorySegment ADDR = BafLib.findOrThrow("baf2sql_array_close_storage");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * void baf2sql_array_close_storage(uint64_t handle)
   *}
   */
  public static FunctionDescriptor baf2sql_array_close_storage$descriptor() {
    return baf2sql_array_close_storage.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * void baf2sql_array_close_storage(uint64_t handle)
   *}
   */
  public static MethodHandle baf2sql_array_close_storage$handle() {
    return baf2sql_array_close_storage.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * void baf2sql_array_close_storage(uint64_t handle)
   *}
   */
  public static MemorySegment baf2sql_array_close_storage$address() {
    return baf2sql_array_close_storage.ADDR;
  }

  /**
   * {@snippet lang = c:
   * void baf2sql_array_close_storage(uint64_t handle)
   *}
   */
  public static void baf2sql_array_close_storage(long handle) {
    var mh$ = baf2sql_array_close_storage.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("baf2sql_array_close_storage", handle);
      }
      mh$.invokeExact(handle);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  private static class baf2sql_get_last_error_string {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(BafLib.C_INT,
        BafLib.C_POINTER, BafLib.C_INT);

    public static final MemorySegment ADDR = BafLib.findOrThrow("baf2sql_get_last_error_string");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t baf2sql_get_last_error_string(char *buf, uint32_t len)
   *}
   */
  public static FunctionDescriptor baf2sql_get_last_error_string$descriptor() {
    return baf2sql_get_last_error_string.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t baf2sql_get_last_error_string(char *buf, uint32_t len)
   *}
   */
  public static MethodHandle baf2sql_get_last_error_string$handle() {
    return baf2sql_get_last_error_string.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t baf2sql_get_last_error_string(char *buf, uint32_t len)
   *}
   */
  public static MemorySegment baf2sql_get_last_error_string$address() {
    return baf2sql_get_last_error_string.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t baf2sql_get_last_error_string(char *buf, uint32_t len)
   *}
   */
  public static int baf2sql_get_last_error_string(MemorySegment buf, int len) {
    var mh$ = baf2sql_get_last_error_string.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("baf2sql_get_last_error_string", buf, len);
      }
      return (int) mh$.invokeExact(buf, len);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  private static class baf2sql_set_num_threads {

    public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(BafLib.C_INT);

    public static final MemorySegment ADDR = BafLib.findOrThrow("baf2sql_set_num_threads");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * void baf2sql_set_num_threads(uint32_t n)
   *}
   */
  public static FunctionDescriptor baf2sql_set_num_threads$descriptor() {
    return baf2sql_set_num_threads.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * void baf2sql_set_num_threads(uint32_t n)
   *}
   */
  public static MethodHandle baf2sql_set_num_threads$handle() {
    return baf2sql_set_num_threads.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * void baf2sql_set_num_threads(uint32_t n)
   *}
   */
  public static MemorySegment baf2sql_set_num_threads$address() {
    return baf2sql_set_num_threads.ADDR;
  }

  /**
   * {@snippet lang = c:
   * void baf2sql_set_num_threads(uint32_t n)
   *}
   */
  public static void baf2sql_set_num_threads(int n) {
    var mh$ = baf2sql_set_num_threads.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("baf2sql_set_num_threads", n);
      }
      mh$.invokeExact(n);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  private static final long INT64_MAX = 9223372036854775807L;

  /**
   * {@snippet lang = c:
   * #define INT64_MAX 9223372036854775807
   *}
   */
  public static long INT64_MAX() {
    return INT64_MAX;
  }

  private static final long INT64_MIN = -9223372036854775808L;

  /**
   * {@snippet lang = c:
   * #define INT64_MIN -9223372036854775808
   *}
   */
  public static long INT64_MIN() {
    return INT64_MIN;
  }

  private static final long UINT64_MAX = -1L;

  /**
   * {@snippet lang = c:
   * #define UINT64_MAX -1
   *}
   */
  public static long UINT64_MAX() {
    return UINT64_MAX;
  }

  private static final long __INT_LEAST64_MIN = -9223372036854775808L;

  /**
   * {@snippet lang = c:
   * #define __INT_LEAST64_MIN -9223372036854775808
   *}
   */
  public static long __INT_LEAST64_MIN() {
    return __INT_LEAST64_MIN;
  }

  private static final long __INT_LEAST64_MAX = 9223372036854775807L;

  /**
   * {@snippet lang = c:
   * #define __INT_LEAST64_MAX 9223372036854775807
   *}
   */
  public static long __INT_LEAST64_MAX() {
    return __INT_LEAST64_MAX;
  }

  private static final long __UINT_LEAST64_MAX = -1L;

  /**
   * {@snippet lang = c:
   * #define __UINT_LEAST64_MAX -1
   *}
   */
  public static long __UINT_LEAST64_MAX() {
    return __UINT_LEAST64_MAX;
  }

  private static final int __INT_LEAST32_MIN = (int) -2147483648L;

  /**
   * {@snippet lang = c:
   * #define __INT_LEAST32_MIN -2147483648
   *}
   */
  public static int __INT_LEAST32_MIN() {
    return __INT_LEAST32_MIN;
  }

  private static final int __INT_LEAST32_MAX = (int) 2147483647L;

  /**
   * {@snippet lang = c:
   * #define __INT_LEAST32_MAX 2147483647
   *}
   */
  public static int __INT_LEAST32_MAX() {
    return __INT_LEAST32_MAX;
  }

  private static final int __UINT_LEAST32_MAX = (int) 4294967295L;

  /**
   * {@snippet lang = c:
   * #define __UINT_LEAST32_MAX 4294967295
   *}
   */
  public static int __UINT_LEAST32_MAX() {
    return __UINT_LEAST32_MAX;
  }

  private static final int __INT_LEAST16_MIN = (int) -32768L;

  /**
   * {@snippet lang = c:
   * #define __INT_LEAST16_MIN -32768
   *}
   */
  public static int __INT_LEAST16_MIN() {
    return __INT_LEAST16_MIN;
  }

  private static final int __INT_LEAST16_MAX = (int) 32767L;

  /**
   * {@snippet lang = c:
   * #define __INT_LEAST16_MAX 32767
   *}
   */
  public static int __INT_LEAST16_MAX() {
    return __INT_LEAST16_MAX;
  }

  private static final int __UINT_LEAST16_MAX = (int) 65535L;

  /**
   * {@snippet lang = c:
   * #define __UINT_LEAST16_MAX 65535
   *}
   */
  public static int __UINT_LEAST16_MAX() {
    return __UINT_LEAST16_MAX;
  }

  private static final int __INT_LEAST8_MIN = (int) -128L;

  /**
   * {@snippet lang = c:
   * #define __INT_LEAST8_MIN -128
   *}
   */
  public static int __INT_LEAST8_MIN() {
    return __INT_LEAST8_MIN;
  }

  private static final int __INT_LEAST8_MAX = (int) 127L;

  /**
   * {@snippet lang = c:
   * #define __INT_LEAST8_MAX 127
   *}
   */
  public static int __INT_LEAST8_MAX() {
    return __INT_LEAST8_MAX;
  }

  private static final int __UINT_LEAST8_MAX = (int) 255L;

  /**
   * {@snippet lang = c:
   * #define __UINT_LEAST8_MAX 255
   *}
   */
  public static int __UINT_LEAST8_MAX() {
    return __UINT_LEAST8_MAX;
  }

  private static final long INT_LEAST64_MIN = -9223372036854775808L;

  /**
   * {@snippet lang = c:
   * #define INT_LEAST64_MIN -9223372036854775808
   *}
   */
  public static long INT_LEAST64_MIN() {
    return INT_LEAST64_MIN;
  }

  private static final long INT_LEAST64_MAX = 9223372036854775807L;

  /**
   * {@snippet lang = c:
   * #define INT_LEAST64_MAX 9223372036854775807
   *}
   */
  public static long INT_LEAST64_MAX() {
    return INT_LEAST64_MAX;
  }

  private static final long UINT_LEAST64_MAX = -1L;

  /**
   * {@snippet lang = c:
   * #define UINT_LEAST64_MAX -1
   *}
   */
  public static long UINT_LEAST64_MAX() {
    return UINT_LEAST64_MAX;
  }

  private static final long INT_FAST64_MIN = -9223372036854775808L;

  /**
   * {@snippet lang = c:
   * #define INT_FAST64_MIN -9223372036854775808
   *}
   */
  public static long INT_FAST64_MIN() {
    return INT_FAST64_MIN;
  }

  private static final long INT_FAST64_MAX = 9223372036854775807L;

  /**
   * {@snippet lang = c:
   * #define INT_FAST64_MAX 9223372036854775807
   *}
   */
  public static long INT_FAST64_MAX() {
    return INT_FAST64_MAX;
  }

  private static final long UINT_FAST64_MAX = -1L;

  /**
   * {@snippet lang = c:
   * #define UINT_FAST64_MAX -1
   *}
   */
  public static long UINT_FAST64_MAX() {
    return UINT_FAST64_MAX;
  }

  private static final int INT32_MAX = (int) 2147483647L;

  /**
   * {@snippet lang = c:
   * #define INT32_MAX 2147483647
   *}
   */
  public static int INT32_MAX() {
    return INT32_MAX;
  }

  private static final int INT32_MIN = (int) -2147483648L;

  /**
   * {@snippet lang = c:
   * #define INT32_MIN -2147483648
   *}
   */
  public static int INT32_MIN() {
    return INT32_MIN;
  }

  private static final int UINT32_MAX = (int) 4294967295L;

  /**
   * {@snippet lang = c:
   * #define UINT32_MAX 4294967295
   *}
   */
  public static int UINT32_MAX() {
    return UINT32_MAX;
  }

  private static final int INT_LEAST32_MIN = (int) -2147483648L;

  /**
   * {@snippet lang = c:
   * #define INT_LEAST32_MIN -2147483648
   *}
   */
  public static int INT_LEAST32_MIN() {
    return INT_LEAST32_MIN;
  }

  private static final int INT_LEAST32_MAX = (int) 2147483647L;

  /**
   * {@snippet lang = c:
   * #define INT_LEAST32_MAX 2147483647
   *}
   */
  public static int INT_LEAST32_MAX() {
    return INT_LEAST32_MAX;
  }

  private static final int UINT_LEAST32_MAX = (int) 4294967295L;

  /**
   * {@snippet lang = c:
   * #define UINT_LEAST32_MAX 4294967295
   *}
   */
  public static int UINT_LEAST32_MAX() {
    return UINT_LEAST32_MAX;
  }

  private static final int INT_FAST32_MIN = (int) -2147483648L;

  /**
   * {@snippet lang = c:
   * #define INT_FAST32_MIN -2147483648
   *}
   */
  public static int INT_FAST32_MIN() {
    return INT_FAST32_MIN;
  }

  private static final int INT_FAST32_MAX = (int) 2147483647L;

  /**
   * {@snippet lang = c:
   * #define INT_FAST32_MAX 2147483647
   *}
   */
  public static int INT_FAST32_MAX() {
    return INT_FAST32_MAX;
  }

  private static final int UINT_FAST32_MAX = (int) 4294967295L;

  /**
   * {@snippet lang = c:
   * #define UINT_FAST32_MAX 4294967295
   *}
   */
  public static int UINT_FAST32_MAX() {
    return UINT_FAST32_MAX;
  }

  private static final int INT16_MAX = (int) 32767L;

  /**
   * {@snippet lang = c:
   * #define INT16_MAX 32767
   *}
   */
  public static int INT16_MAX() {
    return INT16_MAX;
  }

  private static final int INT16_MIN = (int) -32768L;

  /**
   * {@snippet lang = c:
   * #define INT16_MIN -32768
   *}
   */
  public static int INT16_MIN() {
    return INT16_MIN;
  }

  private static final int UINT16_MAX = (int) 65535L;

  /**
   * {@snippet lang = c:
   * #define UINT16_MAX 65535
   *}
   */
  public static int UINT16_MAX() {
    return UINT16_MAX;
  }

  private static final int INT_LEAST16_MIN = (int) -32768L;

  /**
   * {@snippet lang = c:
   * #define INT_LEAST16_MIN -32768
   *}
   */
  public static int INT_LEAST16_MIN() {
    return INT_LEAST16_MIN;
  }

  private static final int INT_LEAST16_MAX = (int) 32767L;

  /**
   * {@snippet lang = c:
   * #define INT_LEAST16_MAX 32767
   *}
   */
  public static int INT_LEAST16_MAX() {
    return INT_LEAST16_MAX;
  }

  private static final int UINT_LEAST16_MAX = (int) 65535L;

  /**
   * {@snippet lang = c:
   * #define UINT_LEAST16_MAX 65535
   *}
   */
  public static int UINT_LEAST16_MAX() {
    return UINT_LEAST16_MAX;
  }

  private static final int INT_FAST16_MIN = (int) -32768L;

  /**
   * {@snippet lang = c:
   * #define INT_FAST16_MIN -32768
   *}
   */
  public static int INT_FAST16_MIN() {
    return INT_FAST16_MIN;
  }

  private static final int INT_FAST16_MAX = (int) 32767L;

  /**
   * {@snippet lang = c:
   * #define INT_FAST16_MAX 32767
   *}
   */
  public static int INT_FAST16_MAX() {
    return INT_FAST16_MAX;
  }

  private static final int UINT_FAST16_MAX = (int) 65535L;

  /**
   * {@snippet lang = c:
   * #define UINT_FAST16_MAX 65535
   *}
   */
  public static int UINT_FAST16_MAX() {
    return UINT_FAST16_MAX;
  }

  private static final int INT8_MAX = (int) 127L;

  /**
   * {@snippet lang = c:
   * #define INT8_MAX 127
   *}
   */
  public static int INT8_MAX() {
    return INT8_MAX;
  }

  private static final int INT8_MIN = (int) -128L;

  /**
   * {@snippet lang = c:
   * #define INT8_MIN -128
   *}
   */
  public static int INT8_MIN() {
    return INT8_MIN;
  }

  private static final int UINT8_MAX = (int) 255L;

  /**
   * {@snippet lang = c:
   * #define UINT8_MAX 255
   *}
   */
  public static int UINT8_MAX() {
    return UINT8_MAX;
  }

  private static final int INT_LEAST8_MIN = (int) -128L;

  /**
   * {@snippet lang = c:
   * #define INT_LEAST8_MIN -128
   *}
   */
  public static int INT_LEAST8_MIN() {
    return INT_LEAST8_MIN;
  }

  private static final int INT_LEAST8_MAX = (int) 127L;

  /**
   * {@snippet lang = c:
   * #define INT_LEAST8_MAX 127
   *}
   */
  public static int INT_LEAST8_MAX() {
    return INT_LEAST8_MAX;
  }

  private static final int UINT_LEAST8_MAX = (int) 255L;

  /**
   * {@snippet lang = c:
   * #define UINT_LEAST8_MAX 255
   *}
   */
  public static int UINT_LEAST8_MAX() {
    return UINT_LEAST8_MAX;
  }

  private static final int INT_FAST8_MIN = (int) -128L;

  /**
   * {@snippet lang = c:
   * #define INT_FAST8_MIN -128
   *}
   */
  public static int INT_FAST8_MIN() {
    return INT_FAST8_MIN;
  }

  private static final int INT_FAST8_MAX = (int) 127L;

  /**
   * {@snippet lang = c:
   * #define INT_FAST8_MAX 127
   *}
   */
  public static int INT_FAST8_MAX() {
    return INT_FAST8_MAX;
  }

  private static final int UINT_FAST8_MAX = (int) 255L;

  /**
   * {@snippet lang = c:
   * #define UINT_FAST8_MAX 255
   *}
   */
  public static int UINT_FAST8_MAX() {
    return UINT_FAST8_MAX;
  }

  private static final long INTPTR_MIN = -9223372036854775808L;

  /**
   * {@snippet lang = c:
   * #define INTPTR_MIN -9223372036854775808
   *}
   */
  public static long INTPTR_MIN() {
    return INTPTR_MIN;
  }

  private static final long INTPTR_MAX = 9223372036854775807L;

  /**
   * {@snippet lang = c:
   * #define INTPTR_MAX 9223372036854775807
   *}
   */
  public static long INTPTR_MAX() {
    return INTPTR_MAX;
  }

  private static final long UINTPTR_MAX = -1L;

  /**
   * {@snippet lang = c:
   * #define UINTPTR_MAX -1
   *}
   */
  public static long UINTPTR_MAX() {
    return UINTPTR_MAX;
  }

  private static final long PTRDIFF_MIN = -9223372036854775808L;

  /**
   * {@snippet lang = c:
   * #define PTRDIFF_MIN -9223372036854775808
   *}
   */
  public static long PTRDIFF_MIN() {
    return PTRDIFF_MIN;
  }

  private static final long PTRDIFF_MAX = 9223372036854775807L;

  /**
   * {@snippet lang = c:
   * #define PTRDIFF_MAX 9223372036854775807
   *}
   */
  public static long PTRDIFF_MAX() {
    return PTRDIFF_MAX;
  }

  private static final long SIZE_MAX = -1L;

  /**
   * {@snippet lang = c:
   * #define SIZE_MAX -1
   *}
   */
  public static long SIZE_MAX() {
    return SIZE_MAX;
  }

  private static final long INTMAX_MIN = -9223372036854775808L;

  /**
   * {@snippet lang = c:
   * #define INTMAX_MIN -9223372036854775808
   *}
   */
  public static long INTMAX_MIN() {
    return INTMAX_MIN;
  }

  private static final long INTMAX_MAX = 9223372036854775807L;

  /**
   * {@snippet lang = c:
   * #define INTMAX_MAX 9223372036854775807
   *}
   */
  public static long INTMAX_MAX() {
    return INTMAX_MAX;
  }

  private static final long UINTMAX_MAX = -1L;

  /**
   * {@snippet lang = c:
   * #define UINTMAX_MAX -1
   *}
   */
  public static long UINTMAX_MAX() {
    return UINTMAX_MAX;
  }

  private static final int SIG_ATOMIC_MIN = (int) -2147483648L;

  /**
   * {@snippet lang = c:
   * #define SIG_ATOMIC_MIN -2147483648
   *}
   */
  public static int SIG_ATOMIC_MIN() {
    return SIG_ATOMIC_MIN;
  }

  private static final int SIG_ATOMIC_MAX = (int) 2147483647L;

  /**
   * {@snippet lang = c:
   * #define SIG_ATOMIC_MAX 2147483647
   *}
   */
  public static int SIG_ATOMIC_MAX() {
    return SIG_ATOMIC_MAX;
  }

  private static final int WINT_MIN = (int) 0L;

  /**
   * {@snippet lang = c:
   * #define WINT_MIN 0
   *}
   */
  public static int WINT_MIN() {
    return WINT_MIN;
  }

  private static final int WINT_MAX = (int) 65535L;

  /**
   * {@snippet lang = c:
   * #define WINT_MAX 65535
   *}
   */
  public static int WINT_MAX() {
    return WINT_MAX;
  }

  private static final int WCHAR_MAX = (int) 65535L;

  /**
   * {@snippet lang = c:
   * #define WCHAR_MAX 65535
   *}
   */
  public static int WCHAR_MAX() {
    return WCHAR_MAX;
  }

  private static final int WCHAR_MIN = (int) 0L;

  /**
   * {@snippet lang = c:
   * #define WCHAR_MIN 0
   *}
   */
  public static int WCHAR_MIN() {
    return WCHAR_MIN;
  }
}

