package io.github.mzmine.modules.io.import_rawdata_waters;

/*
 * Copyright (c) 2004-2025 The mzmine Development Team
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

import java.lang.foreign.ValueLayout.OfBoolean;
import java.lang.foreign.ValueLayout.OfByte;
import java.lang.foreign.ValueLayout.OfFloat;
import java.lang.foreign.ValueLayout.OfInt;
import java.lang.foreign.ValueLayout.OfLong;
import java.lang.foreign.ValueLayout.OfShort;

///
/// ´´´java
///   static final SymbolLookup SYMBOL_LOOKUP = getSymbolLookup();
///
///   private static synchronized SymbolLookup getSymbolLookup() {
///     // load mass lynx base library before
///     System.load(Path.of("external_tools\\waters_raw\\MassLynxRaw.dll").toAbsolutePath().toString());
///     return SymbolLookup.libraryLookup(
///             "external_tools/waters_raw/%s".formatted(System.mapLibraryName("MLReader")), LIBRARY_ARENA)
///         .or(SymbolLookup.loaderLookup()).or(Linker.nativeLinker().defaultLookup());
///   }
///  ´´´

// Generated by jextract

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.file.Path;
import java.util.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;

/**
 * Java wrapper around the mass lynx wrapper. How to replace with new version:
 * <p></p>
 * - Paste new generated MassLynxLib_h class below here, starting with the class definition.
 * <p></p>
 * - refactor from MassLynxLib_h to MassLynxLib
 * <p></p>
 * - format and rearrange - replace SYMBOL_LOOKUP with:
 * <pre>
 *   {@code
 * static final SymbolLookup SYMBOL_LOOKUP = getSymbolLookup();
 * private static synchronized SymbolLookup getSymbolLookup() {
 *   // load mass lynx base library before
 *   System.load(Path.of("external_tools\\waters_raw\\MassLynxRaw.dll").toAbsolutePath().toString());
 *   return SymbolLookup.libraryLookup(
 *           "external_tools/waters_raw/%s".formatted(System.mapLibraryName("MLReader")), LIBRARY_ARENA)
 *       .or(SymbolLookup.loaderLookup()).or(Linker.nativeLinker().defaultLookup());
 * }
 *   }
 * </pre>
 */
public class MassLynxLib {

  public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
  public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
  public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
  public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
  public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
  public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
  public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
  public static final AddressLayout C_POINTER = ValueLayout.ADDRESS.withTargetLayout(
      MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
  public static final ValueLayout.OfInt C_LONG = ValueLayout.JAVA_INT;
  public static final ValueLayout.OfDouble C_LONG_DOUBLE = ValueLayout.JAVA_DOUBLE;
  /**
   * {@snippet lang = c:
   * typedef unsigned long long uintptr_t
   *}
   */
  public static final OfLong uintptr_t = MassLynxLib.C_LONG_LONG;
  /**
   * {@snippet lang = c:
   * typedef char *va_list
   *}
   */
  public static final AddressLayout va_list = MassLynxLib.C_POINTER;
  /**
   * {@snippet lang = c:
   * typedef unsigned long long size_t
   *}
   */
  public static final OfLong size_t = MassLynxLib.C_LONG_LONG;
  /**
   * {@snippet lang = c:
   * typedef long long ptrdiff_t
   *}
   */
  public static final OfLong ptrdiff_t = MassLynxLib.C_LONG_LONG;
  /**
   * {@snippet lang = c:
   * typedef long long intptr_t
   *}
   */
  public static final OfLong intptr_t = MassLynxLib.C_LONG_LONG;
  /**
   * {@snippet lang = c:
   * typedef _Bool __vcrt_bool
   *}
   */
  public static final OfBoolean __vcrt_bool = MassLynxLib.C_BOOL;
  /**
   * {@snippet lang = c:
   * typedef unsigned short wchar_t
   *}
   */
  public static final OfShort wchar_t = MassLynxLib.C_SHORT;
  /**
   * {@snippet lang = c:
   * typedef signed char int8_t
   *}
   */
  public static final OfByte int8_t = MassLynxLib.C_CHAR;
  /**
   * {@snippet lang = c:
   * typedef short int16_t
   *}
   */
  public static final OfShort int16_t = MassLynxLib.C_SHORT;
  /**
   * {@snippet lang = c:
   * typedef int int32_t
   *}
   */
  public static final OfInt int32_t = MassLynxLib.C_INT;
  /**
   * {@snippet lang = c:
   * typedef long long int64_t
   *}
   */
  public static final OfLong int64_t = MassLynxLib.C_LONG_LONG;
  /**
   * {@snippet lang = c:
   * typedef unsigned char uint8_t
   *}
   */
  public static final OfByte uint8_t = MassLynxLib.C_CHAR;
  /**
   * {@snippet lang = c:
   * typedef unsigned short uint16_t
   *}
   */
  public static final OfShort uint16_t = MassLynxLib.C_SHORT;
  /**
   * {@snippet lang = c:
   * typedef unsigned int uint32_t
   *}
   */
  public static final OfInt uint32_t = MassLynxLib.C_INT;
  /**
   * {@snippet lang = c:
   * typedef unsigned long long uint64_t
   *}
   */
  public static final OfLong uint64_t = MassLynxLib.C_LONG_LONG;
  /**
   * {@snippet lang = c:
   * typedef signed char int_least8_t
   *}
   */
  public static final OfByte int_least8_t = MassLynxLib.C_CHAR;
  /**
   * {@snippet lang = c:
   * typedef short int_least16_t
   *}
   */
  public static final OfShort int_least16_t = MassLynxLib.C_SHORT;
  /**
   * {@snippet lang = c:
   * typedef int int_least32_t
   *}
   */
  public static final OfInt int_least32_t = MassLynxLib.C_INT;
  /**
   * {@snippet lang = c:
   * typedef long long int_least64_t
   *}
   */
  public static final OfLong int_least64_t = MassLynxLib.C_LONG_LONG;
  /**
   * {@snippet lang = c:
   * typedef unsigned char uint_least8_t
   *}
   */
  public static final OfByte uint_least8_t = MassLynxLib.C_CHAR;
  /**
   * {@snippet lang = c:
   * typedef unsigned short uint_least16_t
   *}
   */
  public static final OfShort uint_least16_t = MassLynxLib.C_SHORT;
  /**
   * {@snippet lang = c:
   * typedef unsigned int uint_least32_t
   *}
   */
  public static final OfInt uint_least32_t = MassLynxLib.C_INT;
  /**
   * {@snippet lang = c:
   * typedef unsigned long long uint_least64_t
   *}
   */
  public static final OfLong uint_least64_t = MassLynxLib.C_LONG_LONG;
  /**
   * {@snippet lang = c:
   * typedef signed char int_fast8_t
   *}
   */
  public static final OfByte int_fast8_t = MassLynxLib.C_CHAR;
  /**
   * {@snippet lang = c:
   * typedef int int_fast16_t
   *}
   */
  public static final OfInt int_fast16_t = MassLynxLib.C_INT;
  /**
   * {@snippet lang = c:
   * typedef int int_fast32_t
   *}
   */
  public static final OfInt int_fast32_t = MassLynxLib.C_INT;
  /**
   * {@snippet lang = c:
   * typedef long long int_fast64_t
   *}
   */
  public static final OfLong int_fast64_t = MassLynxLib.C_LONG_LONG;
  /**
   * {@snippet lang = c:
   * typedef unsigned char uint_fast8_t
   *}
   */
  public static final OfByte uint_fast8_t = MassLynxLib.C_CHAR;
  /**
   * {@snippet lang = c:
   * typedef unsigned int uint_fast16_t
   *}
   */
  public static final OfInt uint_fast16_t = MassLynxLib.C_INT;
  /**
   * {@snippet lang = c:
   * typedef unsigned int uint_fast32_t
   *}
   */
  public static final OfInt uint_fast32_t = MassLynxLib.C_INT;
  /**
   * {@snippet lang = c:
   * typedef unsigned long long uint_fast64_t
   *}
   */
  public static final OfLong uint_fast64_t = MassLynxLib.C_LONG_LONG;
  /**
   * {@snippet lang = c:
   * typedef long long intmax_t
   *}
   */
  public static final OfLong intmax_t = MassLynxLib.C_LONG_LONG;
  /**
   * {@snippet lang = c:
   * typedef unsigned long long uintmax_t
   *}
   */
  public static final OfLong uintmax_t = MassLynxLib.C_LONG_LONG;
  /**
   * {@snippet lang = c:
   * typedef void *Handle
   *}
   */
  public static final AddressLayout Handle = MassLynxLib.C_POINTER;
  static final Arena LIBRARY_ARENA = Arena.ofAuto();
  static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");
  static final SymbolLookup SYMBOL_LOOKUP = getSymbolLookup();
  private static final int _VCRT_COMPILER_PREPROCESSOR = (int) 1L;
  private static final int _SAL_VERSION = (int) 20L;
  private static final int __SAL_H_VERSION = (int) 180000000L;
  private static final int _USE_DECLSPECS_FOR_SAL = (int) 0L;
  private static final int _USE_ATTRIBUTES_FOR_SAL = (int) 0L;
  private static final int _CRT_PACKING = (int) 8L;
  private static final int _HAS_EXCEPTIONS = (int) 1L;
  private static final int _HAS_CXX17 = (int) 0L;
  private static final int _HAS_CXX20 = (int) 0L;
  private static final int _HAS_CXX23 = (int) 0L;
  private static final int _HAS_CXX26 = (int) 0L;
  private static final int _HAS_NODISCARD = (int) 0L;
  private static final int WCHAR_MIN = (int) 0L;
  private static final int WCHAR_MAX = (int) 65535L;
  private static final int WINT_MIN = (int) 0L;
  private static final int WINT_MAX = (int) 65535L;
  private static final int _VCRUNTIME_DISABLED_WARNINGS = (int) 4514L;
  private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
  private static final int INT8_MIN = (int) -128L;
  private static final int INT16_MIN = (int) -32768L;
  private static final int INT32_MIN = (int) -2147483648L;
  private static final long INT64_MIN = -9223372036854775808L;
  private static final byte INT8_MAX = (byte) 127L;
  private static final short INT16_MAX = (short) 32767L;
  private static final int INT32_MAX = (int) 2147483647L;
  private static final long INT64_MAX = 9223372036854775807L;
  private static final byte UINT8_MAX = (byte) 255L;
  private static final short UINT16_MAX = (short) 65535L;
  private static final int UINT32_MAX = (int) 4294967295L;
  private static final long UINT64_MAX = -1L;
  private static final int INT_LEAST8_MIN = (int) -128L;
  private static final int INT_LEAST16_MIN = (int) -32768L;
  private static final int INT_LEAST32_MIN = (int) -2147483648L;
  private static final long INT_LEAST64_MIN = -9223372036854775808L;
  private static final byte INT_LEAST8_MAX = (byte) 127L;
  private static final short INT_LEAST16_MAX = (short) 32767L;
  private static final int INT_LEAST32_MAX = (int) 2147483647L;
  private static final long INT_LEAST64_MAX = 9223372036854775807L;
  private static final byte UINT_LEAST8_MAX = (byte) 255L;
  private static final short UINT_LEAST16_MAX = (short) 65535L;
  private static final int UINT_LEAST32_MAX = (int) 4294967295L;
  private static final long UINT_LEAST64_MAX = -1L;
  private static final int INT_FAST8_MIN = (int) -128L;
  private static final int INT_FAST16_MIN = (int) -2147483648L;
  private static final int INT_FAST32_MIN = (int) -2147483648L;
  private static final long INT_FAST64_MIN = -9223372036854775808L;
  private static final byte INT_FAST8_MAX = (byte) 127L;
  private static final int INT_FAST16_MAX = (int) 2147483647L;
  private static final int INT_FAST32_MAX = (int) 2147483647L;
  private static final long INT_FAST64_MAX = 9223372036854775807L;
  private static final byte UINT_FAST8_MAX = (byte) 255L;
  private static final int UINT_FAST16_MAX = (int) 4294967295L;
  private static final int UINT_FAST32_MAX = (int) 4294967295L;
  private static final long UINT_FAST64_MAX = -1L;
  private static final long INTPTR_MIN = -9223372036854775808L;
  private static final long INTPTR_MAX = 9223372036854775807L;
  private static final long UINTPTR_MAX = -1L;
  private static final long INTMAX_MIN = -9223372036854775808L;
  private static final long INTMAX_MAX = 9223372036854775807L;
  private static final long UINTMAX_MAX = -1L;
  private static final long PTRDIFF_MIN = -9223372036854775808L;
  private static final long PTRDIFF_MAX = 9223372036854775807L;
  private static final long SIZE_MAX = -1L;
  private static final int SIG_ATOMIC_MIN = (int) -2147483648L;
  private static final int SIG_ATOMIC_MAX = (int) 2147483647L;
  MassLynxLib() {
    // Should not be called directly
  }

  private static synchronized SymbolLookup getSymbolLookup() {
    // load mass lynx base library before
    System.load(Path.of("external_tools\\waters_raw\\MassLynxRaw.dll").toAbsolutePath().toString());
    return SymbolLookup.libraryLookup(
            "external_tools/waters_raw/%s".formatted(System.mapLibraryName("MLReader")), LIBRARY_ARENA)
        .or(SymbolLookup.loaderLookup()).or(Linker.nativeLinker().defaultLookup());
  }

  static void traceDowncall(String name, Object... args) {
    String traceArgs = Arrays.stream(args).map(Object::toString).collect(Collectors.joining(", "));
    System.out.printf("%s(%s)\n", name, traceArgs);
  }

  static MemorySegment findOrThrow(String symbol) {
    return SYMBOL_LOOKUP.find(symbol)
        .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
  }

  static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
    try {
      return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
    } catch (ReflectiveOperationException ex) {
      throw new AssertionError(ex);
    }
  }

  static MemoryLayout align(MemoryLayout layout, long align) {
    return switch (layout) {
      case PaddingLayout p -> p;
      case ValueLayout v -> v.withByteAlignment(align);
      case GroupLayout g -> {
        MemoryLayout[] alignedMembers = g.memberLayouts().stream().map(m -> align(m, align))
            .toArray(MemoryLayout[]::new);
        yield g instanceof StructLayout ? MemoryLayout.structLayout(alignedMembers)
            : MemoryLayout.unionLayout(alignedMembers);
      }
      case SequenceLayout s ->
          MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
    };
  }

  /**
   * {@snippet lang = c:
   * #define _VCRT_COMPILER_PREPROCESSOR 1
   *}
   */
  public static int _VCRT_COMPILER_PREPROCESSOR() {
    return _VCRT_COMPILER_PREPROCESSOR;
  }

  /**
   * {@snippet lang = c:
   * #define _SAL_VERSION 20
   *}
   */
  public static int _SAL_VERSION() {
    return _SAL_VERSION;
  }

  /**
   * {@snippet lang = c:
   * #define __SAL_H_VERSION 180000000
   *}
   */
  public static int __SAL_H_VERSION() {
    return __SAL_H_VERSION;
  }

  /**
   * {@snippet lang = c:
   * #define _USE_DECLSPECS_FOR_SAL 0
   *}
   */
  public static int _USE_DECLSPECS_FOR_SAL() {
    return _USE_DECLSPECS_FOR_SAL;
  }

  /**
   * {@snippet lang = c:
   * #define _USE_ATTRIBUTES_FOR_SAL 0
   *}
   */
  public static int _USE_ATTRIBUTES_FOR_SAL() {
    return _USE_ATTRIBUTES_FOR_SAL;
  }

  /**
   * {@snippet lang = c:
   * #define _CRT_PACKING 8
   *}
   */
  public static int _CRT_PACKING() {
    return _CRT_PACKING;
  }

  /**
   * {@snippet lang = c:
   * #define _HAS_EXCEPTIONS 1
   *}
   */
  public static int _HAS_EXCEPTIONS() {
    return _HAS_EXCEPTIONS;
  }

  /**
   * {@snippet lang = c:
   * #define _HAS_CXX17 0
   *}
   */
  public static int _HAS_CXX17() {
    return _HAS_CXX17;
  }

  /**
   * {@snippet lang = c:
   * #define _HAS_CXX20 0
   *}
   */
  public static int _HAS_CXX20() {
    return _HAS_CXX20;
  }

  /**
   * {@snippet lang = c:
   * #define _HAS_CXX23 0
   *}
   */
  public static int _HAS_CXX23() {
    return _HAS_CXX23;
  }

  /**
   * {@snippet lang = c:
   * #define _HAS_CXX26 0
   *}
   */
  public static int _HAS_CXX26() {
    return _HAS_CXX26;
  }

  /**
   * {@snippet lang = c:
   * #define _HAS_NODISCARD 0
   *}
   */
  public static int _HAS_NODISCARD() {
    return _HAS_NODISCARD;
  }

  /**
   * {@snippet lang = c:
   * #define WCHAR_MIN 0
   *}
   */
  public static int WCHAR_MIN() {
    return WCHAR_MIN;
  }

  /**
   * {@snippet lang = c:
   * #define WCHAR_MAX 65535
   *}
   */
  public static int WCHAR_MAX() {
    return WCHAR_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define WINT_MIN 0
   *}
   */
  public static int WINT_MIN() {
    return WINT_MIN;
  }

  /**
   * {@snippet lang = c:
   * #define WINT_MAX 65535
   *}
   */
  public static int WINT_MAX() {
    return WINT_MAX;
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * void __security_init_cookie()
   *}
   */
  public static FunctionDescriptor __security_init_cookie$descriptor() {
    return __security_init_cookie.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * void __security_init_cookie()
   *}
   */
  public static MethodHandle __security_init_cookie$handle() {
    return __security_init_cookie.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * void __security_init_cookie()
   *}
   */
  public static MemorySegment __security_init_cookie$address() {
    return __security_init_cookie.ADDR;
  }

  /**
   * {@snippet lang = c:
   * void __security_init_cookie()
   *}
   */
  public static void __security_init_cookie() {
    var mh$ = __security_init_cookie.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("__security_init_cookie");
      }
      mh$.invokeExact();
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * void __security_check_cookie(uintptr_t _StackCookie)
   *}
   */
  public static FunctionDescriptor __security_check_cookie$descriptor() {
    return __security_check_cookie.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * void __security_check_cookie(uintptr_t _StackCookie)
   *}
   */
  public static MethodHandle __security_check_cookie$handle() {
    return __security_check_cookie.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * void __security_check_cookie(uintptr_t _StackCookie)
   *}
   */
  public static MemorySegment __security_check_cookie$address() {
    return __security_check_cookie.ADDR;
  }

  /**
   * {@snippet lang = c:
   * void __security_check_cookie(uintptr_t _StackCookie)
   *}
   */
  public static void __security_check_cookie(long _StackCookie) {
    var mh$ = __security_check_cookie.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("__security_check_cookie", _StackCookie);
      }
      mh$.invokeExact(_StackCookie);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * void __report_gsfailure(uintptr_t _StackCookie)
   *}
   */
  public static FunctionDescriptor __report_gsfailure$descriptor() {
    return __report_gsfailure.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * void __report_gsfailure(uintptr_t _StackCookie)
   *}
   */
  public static MethodHandle __report_gsfailure$handle() {
    return __report_gsfailure.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * void __report_gsfailure(uintptr_t _StackCookie)
   *}
   */
  public static MemorySegment __report_gsfailure$address() {
    return __report_gsfailure.ADDR;
  }

  /**
   * {@snippet lang = c:
   * void __report_gsfailure(uintptr_t _StackCookie)
   *}
   */
  public static void __report_gsfailure(long _StackCookie) {
    var mh$ = __report_gsfailure.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("__report_gsfailure", _StackCookie);
      }
      mh$.invokeExact(_StackCookie);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Layout for variable:
   * {@snippet lang = c:
   * extern uintptr_t __security_cookie
   *}
   */
  public static OfLong __security_cookie$layout() {
    return __security_cookie$constants.LAYOUT;
  }

  /**
   * Segment for variable:
   * {@snippet lang = c:
   * extern uintptr_t __security_cookie
   *}
   */
  public static MemorySegment __security_cookie$segment() {
    return __security_cookie$constants.SEGMENT;
  }

  /**
   * Getter for variable:
   * {@snippet lang = c:
   * extern uintptr_t __security_cookie
   *}
   */
  public static long __security_cookie() {
    return __security_cookie$constants.SEGMENT.get(__security_cookie$constants.LAYOUT, 0L);
  }

  /**
   * Setter for variable:
   * {@snippet lang = c:
   * extern uintptr_t __security_cookie
   *}
   */
  public static void __security_cookie(long varValue) {
    __security_cookie$constants.SEGMENT.set(__security_cookie$constants.LAYOUT, 0L, varValue);
  }

  /**
   * Layout for variable:
   * {@snippet lang = c:
   * const float DEFAULT_FLOAT = -1.F
   *}
   */
  public static OfFloat DEFAULT_FLOAT$layout() {
    return DEFAULT_FLOAT$constants.LAYOUT;
  }

  /**
   * Segment for variable:
   * {@snippet lang = c:
   * const float DEFAULT_FLOAT = -1.F
   *}
   */
  public static MemorySegment DEFAULT_FLOAT$segment() {
    return DEFAULT_FLOAT$constants.SEGMENT;
  }

  /**
   * Getter for variable:
   * {@snippet lang = c:
   * const float DEFAULT_FLOAT = -1.F
   *}
   */
  public static float DEFAULT_FLOAT() {
    return DEFAULT_FLOAT$constants.SEGMENT.get(DEFAULT_FLOAT$constants.LAYOUT, 0L);
  }

  /**
   * Setter for variable:
   * {@snippet lang = c:
   * const float DEFAULT_FLOAT = -1.F
   *}
   */
  public static void DEFAULT_FLOAT(float varValue) {
    DEFAULT_FLOAT$constants.SEGMENT.set(DEFAULT_FLOAT$constants.LAYOUT, 0L, varValue);
  }

  /**
   * Layout for variable:
   * {@snippet lang = c:
   * const int DEFAULT_INT = -1
   *}
   */
  public static OfInt DEFAULT_INT$layout() {
    return DEFAULT_INT$constants.LAYOUT;
  }

  /**
   * Segment for variable:
   * {@snippet lang = c:
   * const int DEFAULT_INT = -1
   *}
   */
  public static MemorySegment DEFAULT_INT$segment() {
    return DEFAULT_INT$constants.SEGMENT;
  }

  /**
   * Getter for variable:
   * {@snippet lang = c:
   * const int DEFAULT_INT = -1
   *}
   */
  public static int DEFAULT_INT() {
    return DEFAULT_INT$constants.SEGMENT.get(DEFAULT_INT$constants.LAYOUT, 0L);
  }

  /**
   * Setter for variable:
   * {@snippet lang = c:
   * const int DEFAULT_INT = -1
   *}
   */
  public static void DEFAULT_INT(int varValue) {
    DEFAULT_INT$constants.SEGMENT.set(DEFAULT_INT$constants.LAYOUT, 0L, varValue);
  }

  /**
   * Layout for variable:
   * {@snippet lang = c:
   * const float NO_PRECURSOR = DEFAULT_FLOAT
   *}
   */
  public static OfFloat NO_PRECURSOR$layout() {
    return NO_PRECURSOR$constants.LAYOUT;
  }

  /**
   * Segment for variable:
   * {@snippet lang = c:
   * const float NO_PRECURSOR = DEFAULT_FLOAT
   *}
   */
  public static MemorySegment NO_PRECURSOR$segment() {
    return NO_PRECURSOR$constants.SEGMENT;
  }

  /**
   * Getter for variable:
   * {@snippet lang = c:
   * const float NO_PRECURSOR = DEFAULT_FLOAT
   *}
   */
  public static float NO_PRECURSOR() {
    return NO_PRECURSOR$constants.SEGMENT.get(NO_PRECURSOR$constants.LAYOUT, 0L);
  }

  /**
   * Setter for variable:
   * {@snippet lang = c:
   * const float NO_PRECURSOR = DEFAULT_FLOAT
   *}
   */
  public static void NO_PRECURSOR(float varValue) {
    NO_PRECURSOR$constants.SEGMENT.set(NO_PRECURSOR$constants.LAYOUT, 0L, varValue);
  }

  /**
   * Layout for variable:
   * {@snippet lang = c:
   * const float NO_QUAD_ISOLATION = DEFAULT_FLOAT
   *}
   */
  public static OfFloat NO_QUAD_ISOLATION$layout() {
    return NO_QUAD_ISOLATION$constants.LAYOUT;
  }

  /**
   * Segment for variable:
   * {@snippet lang = c:
   * const float NO_QUAD_ISOLATION = DEFAULT_FLOAT
   *}
   */
  public static MemorySegment NO_QUAD_ISOLATION$segment() {
    return NO_QUAD_ISOLATION$constants.SEGMENT;
  }

  /**
   * Getter for variable:
   * {@snippet lang = c:
   * const float NO_QUAD_ISOLATION = DEFAULT_FLOAT
   *}
   */
  public static float NO_QUAD_ISOLATION() {
    return NO_QUAD_ISOLATION$constants.SEGMENT.get(NO_QUAD_ISOLATION$constants.LAYOUT, 0L);
  }

  /**
   * Setter for variable:
   * {@snippet lang = c:
   * const float NO_QUAD_ISOLATION = DEFAULT_FLOAT
   *}
   */
  public static void NO_QUAD_ISOLATION(float varValue) {
    NO_QUAD_ISOLATION$constants.SEGMENT.set(NO_QUAD_ISOLATION$constants.LAYOUT, 0L, varValue);
  }

  /**
   * Layout for variable:
   * {@snippet lang = c:
   * const float NO_COLLISION_ENERGY = DEFAULT_FLOAT
   *}
   */
  public static OfFloat NO_COLLISION_ENERGY$layout() {
    return NO_COLLISION_ENERGY$constants.LAYOUT;
  }

  /**
   * Segment for variable:
   * {@snippet lang = c:
   * const float NO_COLLISION_ENERGY = DEFAULT_FLOAT
   *}
   */
  public static MemorySegment NO_COLLISION_ENERGY$segment() {
    return NO_COLLISION_ENERGY$constants.SEGMENT;
  }

  /**
   * Getter for variable:
   * {@snippet lang = c:
   * const float NO_COLLISION_ENERGY = DEFAULT_FLOAT
   *}
   */
  public static float NO_COLLISION_ENERGY() {
    return NO_COLLISION_ENERGY$constants.SEGMENT.get(NO_COLLISION_ENERGY$constants.LAYOUT, 0L);
  }

  /**
   * Setter for variable:
   * {@snippet lang = c:
   * const float NO_COLLISION_ENERGY = DEFAULT_FLOAT
   *}
   */
  public static void NO_COLLISION_ENERGY(float varValue) {
    NO_COLLISION_ENERGY$constants.SEGMENT.set(NO_COLLISION_ENERGY$constants.LAYOUT, 0L, varValue);
  }

  /**
   * Layout for variable:
   * {@snippet lang = c:
   * const float NO_MOBILITY = DEFAULT_FLOAT
   *}
   */
  public static OfFloat NO_MOBILITY$layout() {
    return NO_MOBILITY$constants.LAYOUT;
  }

  /**
   * Segment for variable:
   * {@snippet lang = c:
   * const float NO_MOBILITY = DEFAULT_FLOAT
   *}
   */
  public static MemorySegment NO_MOBILITY$segment() {
    return NO_MOBILITY$constants.SEGMENT;
  }

  /**
   * Getter for variable:
   * {@snippet lang = c:
   * const float NO_MOBILITY = DEFAULT_FLOAT
   *}
   */
  public static float NO_MOBILITY() {
    return NO_MOBILITY$constants.SEGMENT.get(NO_MOBILITY$constants.LAYOUT, 0L);
  }

  /**
   * Setter for variable:
   * {@snippet lang = c:
   * const float NO_MOBILITY = DEFAULT_FLOAT
   *}
   */
  public static void NO_MOBILITY(float varValue) {
    NO_MOBILITY$constants.SEGMENT.set(NO_MOBILITY$constants.LAYOUT, 0L, varValue);
  }

  /**
   * Layout for variable:
   * {@snippet lang = c:
   * const float NO_POSITION = DEFAULT_FLOAT
   *}
   */
  public static OfFloat NO_POSITION$layout() {
    return NO_POSITION$constants.LAYOUT;
  }

  /**
   * Segment for variable:
   * {@snippet lang = c:
   * const float NO_POSITION = DEFAULT_FLOAT
   *}
   */
  public static MemorySegment NO_POSITION$segment() {
    return NO_POSITION$constants.SEGMENT;
  }

  /**
   * Getter for variable:
   * {@snippet lang = c:
   * const float NO_POSITION = DEFAULT_FLOAT
   *}
   */
  public static float NO_POSITION() {
    return NO_POSITION$constants.SEGMENT.get(NO_POSITION$constants.LAYOUT, 0L);
  }

  /**
   * Setter for variable:
   * {@snippet lang = c:
   * const float NO_POSITION = DEFAULT_FLOAT
   *}
   */
  public static void NO_POSITION(float varValue) {
    NO_POSITION$constants.SEGMENT.set(NO_POSITION$constants.LAYOUT, 0L, varValue);
  }

  /**
   * Layout for variable:
   * {@snippet lang = c:
   * const int32_t NO_DRIFT_SCANS = DEFAULT_INT
   *}
   */
  public static OfInt NO_DRIFT_SCANS$layout() {
    return NO_DRIFT_SCANS$constants.LAYOUT;
  }

  /**
   * Segment for variable:
   * {@snippet lang = c:
   * const int32_t NO_DRIFT_SCANS = DEFAULT_INT
   *}
   */
  public static MemorySegment NO_DRIFT_SCANS$segment() {
    return NO_DRIFT_SCANS$constants.SEGMENT;
  }

  /**
   * Getter for variable:
   * {@snippet lang = c:
   * const int32_t NO_DRIFT_SCANS = DEFAULT_INT
   *}
   */
  public static int NO_DRIFT_SCANS() {
    return NO_DRIFT_SCANS$constants.SEGMENT.get(NO_DRIFT_SCANS$constants.LAYOUT, 0L);
  }

  /**
   * Setter for variable:
   * {@snippet lang = c:
   * const int32_t NO_DRIFT_SCANS = DEFAULT_INT
   *}
   */
  public static void NO_DRIFT_SCANS(int varValue) {
    NO_DRIFT_SCANS$constants.SEGMENT.set(NO_DRIFT_SCANS$constants.LAYOUT, 0L, varValue);
  }

  /**
   * Layout for variable:
   * {@snippet lang = c:
   * const int32_t NO_LOCKMASS_FUNCTION = DEFAULT_INT
   *}
   */
  public static OfInt NO_LOCKMASS_FUNCTION$layout() {
    return NO_LOCKMASS_FUNCTION$constants.LAYOUT;
  }

  /**
   * Segment for variable:
   * {@snippet lang = c:
   * const int32_t NO_LOCKMASS_FUNCTION = DEFAULT_INT
   *}
   */
  public static MemorySegment NO_LOCKMASS_FUNCTION$segment() {
    return NO_LOCKMASS_FUNCTION$constants.SEGMENT;
  }

  /**
   * Getter for variable:
   * {@snippet lang = c:
   * const int32_t NO_LOCKMASS_FUNCTION = DEFAULT_INT
   *}
   */
  public static int NO_LOCKMASS_FUNCTION() {
    return NO_LOCKMASS_FUNCTION$constants.SEGMENT.get(NO_LOCKMASS_FUNCTION$constants.LAYOUT, 0L);
  }

  /**
   * Setter for variable:
   * {@snippet lang = c:
   * const int32_t NO_LOCKMASS_FUNCTION = DEFAULT_INT
   *}
   */
  public static void NO_LOCKMASS_FUNCTION(int varValue) {
    NO_LOCKMASS_FUNCTION$constants.SEGMENT.set(NO_LOCKMASS_FUNCTION$constants.LAYOUT, 0L, varValue);
  }

  /**
   * Layout for variable:
   * {@snippet lang = c:
   * const int32_t NO_PROFILE_INFORMATION = DEFAULT_INT
   *}
   */
  public static OfInt NO_PROFILE_INFORMATION$layout() {
    return NO_PROFILE_INFORMATION$constants.LAYOUT;
  }

  /**
   * Segment for variable:
   * {@snippet lang = c:
   * const int32_t NO_PROFILE_INFORMATION = DEFAULT_INT
   *}
   */
  public static MemorySegment NO_PROFILE_INFORMATION$segment() {
    return NO_PROFILE_INFORMATION$constants.SEGMENT;
  }

  /**
   * Getter for variable:
   * {@snippet lang = c:
   * const int32_t NO_PROFILE_INFORMATION = DEFAULT_INT
   *}
   */
  public static int NO_PROFILE_INFORMATION() {
    return NO_PROFILE_INFORMATION$constants.SEGMENT.get(NO_PROFILE_INFORMATION$constants.LAYOUT,
        0L);
  }

  /**
   * Setter for variable:
   * {@snippet lang = c:
   * const int32_t NO_PROFILE_INFORMATION = DEFAULT_INT
   *}
   */
  public static void NO_PROFILE_INFORMATION(int varValue) {
    NO_PROFILE_INFORMATION$constants.SEGMENT.set(NO_PROFILE_INFORMATION$constants.LAYOUT, 0L,
        varValue);
  }

  /**
   * Layout for variable:
   * {@snippet lang = c:
   * const float NO_RT = DEFAULT_FLOAT
   *}
   */
  public static OfFloat NO_RT$layout() {
    return NO_RT$constants.LAYOUT;
  }

  /**
   * Segment for variable:
   * {@snippet lang = c:
   * const float NO_RT = DEFAULT_FLOAT
   *}
   */
  public static MemorySegment NO_RT$segment() {
    return NO_RT$constants.SEGMENT;
  }

  /**
   * Getter for variable:
   * {@snippet lang = c:
   * const float NO_RT = DEFAULT_FLOAT
   *}
   */
  public static float NO_RT() {
    return NO_RT$constants.SEGMENT.get(NO_RT$constants.LAYOUT, 0L);
  }

  /**
   * Setter for variable:
   * {@snippet lang = c:
   * const float NO_RT = DEFAULT_FLOAT
   *}
   */
  public static void NO_RT(float varValue) {
    NO_RT$constants.SEGMENT.set(NO_RT$constants.LAYOUT, 0L, varValue);
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * Handle openFile(const char *path)
   *}
   */
  public static FunctionDescriptor openFile$descriptor() {
    return openFile.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * Handle openFile(const char *path)
   *}
   */
  public static MethodHandle openFile$handle() {
    return openFile.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * Handle openFile(const char *path)
   *}
   */
  public static MemorySegment openFile$address() {
    return openFile.ADDR;
  }

  /**
   * {@snippet lang = c:
   * Handle openFile(const char *path)
   *}
   */
  public static MemorySegment openFile(MemorySegment path) {
    var mh$ = openFile.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("openFile", path);
      }
      return (MemorySegment) mh$.invokeExact(path);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t closeFile(Handle handle)
   *}
   */
  public static FunctionDescriptor closeFile$descriptor() {
    return closeFile.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t closeFile(Handle handle)
   *}
   */
  public static MethodHandle closeFile$handle() {
    return closeFile.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t closeFile(Handle handle)
   *}
   */
  public static MemorySegment closeFile$address() {
    return closeFile.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t closeFile(Handle handle)
   *}
   */
  public static int closeFile(MemorySegment handle) {
    var mh$ = closeFile.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("closeFile", handle);
      }
      return (int) mh$.invokeExact(handle);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * int32_t getAcquisitionDate(Handle handle, char *buffer, int32_t bufferSize)
   *}
   */
  public static FunctionDescriptor getAcquisitionDate$descriptor() {
    return getAcquisitionDate.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * int32_t getAcquisitionDate(Handle handle, char *buffer, int32_t bufferSize)
   *}
   */
  public static MethodHandle getAcquisitionDate$handle() {
    return getAcquisitionDate.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * int32_t getAcquisitionDate(Handle handle, char *buffer, int32_t bufferSize)
   *}
   */
  public static MemorySegment getAcquisitionDate$address() {
    return getAcquisitionDate.ADDR;
  }

  /**
   * {@snippet lang = c:
   * int32_t getAcquisitionDate(Handle handle, char *buffer, int32_t bufferSize)
   *}
   */
  public static int getAcquisitionDate(MemorySegment handle, MemorySegment buffer, int bufferSize) {
    var mh$ = getAcquisitionDate.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getAcquisitionDate", handle, buffer, bufferSize);
      }
      return (int) mh$.invokeExact(handle, buffer, bufferSize);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t setCentroid(Handle handle, int32_t centroid)
   *}
   */
  public static FunctionDescriptor setCentroid$descriptor() {
    return setCentroid.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t setCentroid(Handle handle, int32_t centroid)
   *}
   */
  public static MethodHandle setCentroid$handle() {
    return setCentroid.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t setCentroid(Handle handle, int32_t centroid)
   *}
   */
  public static MemorySegment setCentroid$address() {
    return setCentroid.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t setCentroid(Handle handle, int32_t centroid)
   *}
   */
  public static int setCentroid(MemorySegment handle, int centroid) {
    var mh$ = setCentroid.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("setCentroid", handle, centroid);
      }
      return (int) mh$.invokeExact(handle, centroid);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t applyAutoLockmassCorrection(Handle handle)
   *}
   */
  public static FunctionDescriptor applyAutoLockmassCorrection$descriptor() {
    return applyAutoLockmassCorrection.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t applyAutoLockmassCorrection(Handle handle)
   *}
   */
  public static MethodHandle applyAutoLockmassCorrection$handle() {
    return applyAutoLockmassCorrection.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t applyAutoLockmassCorrection(Handle handle)
   *}
   */
  public static MemorySegment applyAutoLockmassCorrection$address() {
    return applyAutoLockmassCorrection.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t applyAutoLockmassCorrection(Handle handle)
   *}
   */
  public static int applyAutoLockmassCorrection(MemorySegment handle) {
    var mh$ = applyAutoLockmassCorrection.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("applyAutoLockmassCorrection", handle);
      }
      return (int) mh$.invokeExact(handle);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t isLockMassCorrected(Handle handle)
   *}
   */
  public static FunctionDescriptor isLockMassCorrected$descriptor() {
    return isLockMassCorrected.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t isLockMassCorrected(Handle handle)
   *}
   */
  public static MethodHandle isLockMassCorrected$handle() {
    return isLockMassCorrected.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t isLockMassCorrected(Handle handle)
   *}
   */
  public static MemorySegment isLockMassCorrected$address() {
    return isLockMassCorrected.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t isLockMassCorrected(Handle handle)
   *}
   */
  public static int isLockMassCorrected(MemorySegment handle) {
    var mh$ = isLockMassCorrected.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("isLockMassCorrected", handle);
      }
      return (int) mh$.invokeExact(handle);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t applyCustomLockmassCorrection(Handle handle, float lockmass)
   *}
   */
  public static FunctionDescriptor applyCustomLockmassCorrection$descriptor() {
    return applyCustomLockmassCorrection.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t applyCustomLockmassCorrection(Handle handle, float lockmass)
   *}
   */
  public static MethodHandle applyCustomLockmassCorrection$handle() {
    return applyCustomLockmassCorrection.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t applyCustomLockmassCorrection(Handle handle, float lockmass)
   *}
   */
  public static MemorySegment applyCustomLockmassCorrection$address() {
    return applyCustomLockmassCorrection.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t applyCustomLockmassCorrection(Handle handle, float lockmass)
   *}
   */
  public static int applyCustomLockmassCorrection(MemorySegment handle, float lockmass) {
    var mh$ = applyCustomLockmassCorrection.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("applyCustomLockmassCorrection", handle, lockmass);
      }
      return (int) mh$.invokeExact(handle, lockmass);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t getNumberOfScans(Handle handle)
   *}
   */
  public static FunctionDescriptor getNumberOfScans$descriptor() {
    return getNumberOfScans.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t getNumberOfScans(Handle handle)
   *}
   */
  public static MethodHandle getNumberOfScans$handle() {
    return getNumberOfScans.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t getNumberOfScans(Handle handle)
   *}
   */
  public static MemorySegment getNumberOfScans$address() {
    return getNumberOfScans.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t getNumberOfScans(Handle handle)
   *}
   */
  public static int getNumberOfScans(MemorySegment handle) {
    var mh$ = getNumberOfScans.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getNumberOfScans", handle);
      }
      return (int) mh$.invokeExact(handle);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t getNumberOfScansInFunction(Handle handle, uint32_t function)
   *}
   */
  public static FunctionDescriptor getNumberOfScansInFunction$descriptor() {
    return getNumberOfScansInFunction.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t getNumberOfScansInFunction(Handle handle, uint32_t function)
   *}
   */
  public static MethodHandle getNumberOfScansInFunction$handle() {
    return getNumberOfScansInFunction.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t getNumberOfScansInFunction(Handle handle, uint32_t function)
   *}
   */
  public static MemorySegment getNumberOfScansInFunction$address() {
    return getNumberOfScansInFunction.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t getNumberOfScansInFunction(Handle handle, uint32_t function)
   *}
   */
  public static int getNumberOfScansInFunction(MemorySegment handle, int function) {
    var mh$ = getNumberOfScansInFunction.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getNumberOfScansInFunction", handle, function);
      }
      return (int) mh$.invokeExact(handle, function);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t getNumberOfFunctions(Handle handle)
   *}
   */
  public static FunctionDescriptor getNumberOfFunctions$descriptor() {
    return getNumberOfFunctions.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t getNumberOfFunctions(Handle handle)
   *}
   */
  public static MethodHandle getNumberOfFunctions$handle() {
    return getNumberOfFunctions.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t getNumberOfFunctions(Handle handle)
   *}
   */
  public static MemorySegment getNumberOfFunctions$address() {
    return getNumberOfFunctions.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t getNumberOfFunctions(Handle handle)
   *}
   */
  public static int getNumberOfFunctions(MemorySegment handle) {
    var mh$ = getNumberOfFunctions.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getNumberOfFunctions", handle);
      }
      return (int) mh$.invokeExact(handle);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t getMsLevel(Handle handle, uint32_t function)
   *}
   */
  public static FunctionDescriptor getMsLevel$descriptor() {
    return getMsLevel.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t getMsLevel(Handle handle, uint32_t function)
   *}
   */
  public static MethodHandle getMsLevel$handle() {
    return getMsLevel.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t getMsLevel(Handle handle, uint32_t function)
   *}
   */
  public static MemorySegment getMsLevel$address() {
    return getMsLevel.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t getMsLevel(Handle handle, uint32_t function)
   *}
   */
  public static int getMsLevel(MemorySegment handle, int function) {
    var mh$ = getMsLevel.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getMsLevel", handle, function);
      }
      return (int) mh$.invokeExact(handle, function);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * int32_t getLockmassFunction(Handle handle)
   *}
   */
  public static FunctionDescriptor getLockmassFunction$descriptor() {
    return getLockmassFunction.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * int32_t getLockmassFunction(Handle handle)
   *}
   */
  public static MethodHandle getLockmassFunction$handle() {
    return getLockmassFunction.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * int32_t getLockmassFunction(Handle handle)
   *}
   */
  public static MemorySegment getLockmassFunction$address() {
    return getLockmassFunction.ADDR;
  }

  /**
   * {@snippet lang = c:
   * int32_t getLockmassFunction(Handle handle)
   *}
   */
  public static int getLockmassFunction(MemorySegment handle) {
    var mh$ = getLockmassFunction.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getLockmassFunction", handle);
      }
      return (int) mh$.invokeExact(handle);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t isIonMobilityFile(Handle handle)
   *}
   */
  public static FunctionDescriptor isIonMobilityFile$descriptor() {
    return isIonMobilityFile.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t isIonMobilityFile(Handle handle)
   *}
   */
  public static MethodHandle isIonMobilityFile$handle() {
    return isIonMobilityFile.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t isIonMobilityFile(Handle handle)
   *}
   */
  public static MemorySegment isIonMobilityFile$address() {
    return isIonMobilityFile.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t isIonMobilityFile(Handle handle)
   *}
   */
  public static int isIonMobilityFile(MemorySegment handle) {
    var mh$ = isIonMobilityFile.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("isIonMobilityFile", handle);
      }
      return (int) mh$.invokeExact(handle);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t getNumberOfMobilityScans(Handle handle, int32_t function)
   *}
   */
  public static FunctionDescriptor getNumberOfMobilityScans$descriptor() {
    return getNumberOfMobilityScans.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t getNumberOfMobilityScans(Handle handle, int32_t function)
   *}
   */
  public static MethodHandle getNumberOfMobilityScans$handle() {
    return getNumberOfMobilityScans.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t getNumberOfMobilityScans(Handle handle, int32_t function)
   *}
   */
  public static MemorySegment getNumberOfMobilityScans$address() {
    return getNumberOfMobilityScans.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t getNumberOfMobilityScans(Handle handle, int32_t function)
   *}
   */
  public static int getNumberOfMobilityScans(MemorySegment handle, int function) {
    var mh$ = getNumberOfMobilityScans.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getNumberOfMobilityScans", handle, function);
      }
      return (int) mh$.invokeExact(handle, function);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t isIonMobilityFunction(Handle handle, int32_t function)
   *}
   */
  public static FunctionDescriptor isIonMobilityFunction$descriptor() {
    return isIonMobilityFunction.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t isIonMobilityFunction(Handle handle, int32_t function)
   *}
   */
  public static MethodHandle isIonMobilityFunction$handle() {
    return isIonMobilityFunction.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t isIonMobilityFunction(Handle handle, int32_t function)
   *}
   */
  public static MemorySegment isIonMobilityFunction$address() {
    return isIonMobilityFunction.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t isIonMobilityFunction(Handle handle, int32_t function)
   *}
   */
  public static int isIonMobilityFunction(MemorySegment handle, int function) {
    var mh$ = isIonMobilityFunction.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("isIonMobilityFunction", handle, function);
      }
      return (int) mh$.invokeExact(handle, function);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t isDdaFile(Handle handle)
   *}
   */
  public static FunctionDescriptor isDdaFile$descriptor() {
    return isDdaFile.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t isDdaFile(Handle handle)
   *}
   */
  public static MethodHandle isDdaFile$handle() {
    return isDdaFile.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t isDdaFile(Handle handle)
   *}
   */
  public static MemorySegment isDdaFile$address() {
    return isDdaFile.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t isDdaFile(Handle handle)
   *}
   */
  public static int isDdaFile(MemorySegment handle) {
    var mh$ = isDdaFile.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("isDdaFile", handle);
      }
      return (int) mh$.invokeExact(handle);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t isImagingFile(Handle handle)
   *}
   */
  public static FunctionDescriptor isImagingFile$descriptor() {
    return isImagingFile.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t isImagingFile(Handle handle)
   *}
   */
  public static MethodHandle isImagingFile$handle() {
    return isImagingFile.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t isImagingFile(Handle handle)
   *}
   */
  public static MemorySegment isImagingFile$address() {
    return isImagingFile.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t isImagingFile(Handle handle)
   *}
   */
  public static int isImagingFile(MemorySegment handle) {
    var mh$ = isImagingFile.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("isImagingFile", handle);
      }
      return (int) mh$.invokeExact(handle);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * void setAbsoluteThreshold(Handle handle, float threshold)
   *}
   */
  public static FunctionDescriptor setAbsoluteThreshold$descriptor() {
    return setAbsoluteThreshold.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * void setAbsoluteThreshold(Handle handle, float threshold)
   *}
   */
  public static MethodHandle setAbsoluteThreshold$handle() {
    return setAbsoluteThreshold.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * void setAbsoluteThreshold(Handle handle, float threshold)
   *}
   */
  public static MemorySegment setAbsoluteThreshold$address() {
    return setAbsoluteThreshold.ADDR;
  }

  /**
   * {@snippet lang = c:
   * void setAbsoluteThreshold(Handle handle, float threshold)
   *}
   */
  public static void setAbsoluteThreshold(MemorySegment handle, float threshold) {
    var mh$ = setAbsoluteThreshold.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("setAbsoluteThreshold", handle, threshold);
      }
      mh$.invokeExact(handle, threshold);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * int32_t getPolarity(Handle handle, int32_t function)
   *}
   */
  public static FunctionDescriptor getPolarity$descriptor() {
    return getPolarity.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * int32_t getPolarity(Handle handle, int32_t function)
   *}
   */
  public static MethodHandle getPolarity$handle() {
    return getPolarity.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * int32_t getPolarity(Handle handle, int32_t function)
   *}
   */
  public static MemorySegment getPolarity$address() {
    return getPolarity.ADDR;
  }

  /**
   * {@snippet lang = c:
   * int32_t getPolarity(Handle handle, int32_t function)
   *}
   */
  public static int getPolarity(MemorySegment handle, int function) {
    var mh$ = getPolarity.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getPolarity", handle, function);
      }
      return (int) mh$.invokeExact(handle, function);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * float getPrecursorMz(Handle handle, int32_t function, int32_t scan)
   *}
   */
  public static FunctionDescriptor getPrecursorMz$descriptor() {
    return getPrecursorMz.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * float getPrecursorMz(Handle handle, int32_t function, int32_t scan)
   *}
   */
  public static MethodHandle getPrecursorMz$handle() {
    return getPrecursorMz.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * float getPrecursorMz(Handle handle, int32_t function, int32_t scan)
   *}
   */
  public static MemorySegment getPrecursorMz$address() {
    return getPrecursorMz.ADDR;
  }

  /**
   * {@snippet lang = c:
   * float getPrecursorMz(Handle handle, int32_t function, int32_t scan)
   *}
   */
  public static float getPrecursorMz(MemorySegment handle, int function, int scan) {
    var mh$ = getPrecursorMz.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getPrecursorMz", handle, function, scan);
      }
      return (float) mh$.invokeExact(handle, function, scan);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * float getMobility(Handle handle, int32_t drift)
   *}
   */
  public static FunctionDescriptor getMobility$descriptor() {
    return getMobility.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * float getMobility(Handle handle, int32_t drift)
   *}
   */
  public static MethodHandle getMobility$handle() {
    return getMobility.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * float getMobility(Handle handle, int32_t drift)
   *}
   */
  public static MemorySegment getMobility$address() {
    return getMobility.ADDR;
  }

  /**
   * {@snippet lang = c:
   * float getMobility(Handle handle, int32_t drift)
   *}
   */
  public static float getMobility(MemorySegment handle, int drift) {
    var mh$ = getMobility.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getMobility", handle, drift);
      }
      return (float) mh$.invokeExact(handle, drift);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * float getLowerIsolationWindow(Handle handle, int32_t function, int32_t scan)
   *}
   */
  public static FunctionDescriptor getLowerIsolationWindow$descriptor() {
    return getLowerIsolationWindow.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * float getLowerIsolationWindow(Handle handle, int32_t function, int32_t scan)
   *}
   */
  public static MethodHandle getLowerIsolationWindow$handle() {
    return getLowerIsolationWindow.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * float getLowerIsolationWindow(Handle handle, int32_t function, int32_t scan)
   *}
   */
  public static MemorySegment getLowerIsolationWindow$address() {
    return getLowerIsolationWindow.ADDR;
  }

  /**
   * {@snippet lang = c:
   * float getLowerIsolationWindow(Handle handle, int32_t function, int32_t scan)
   *}
   */
  public static float getLowerIsolationWindow(MemorySegment handle, int function, int scan) {
    var mh$ = getLowerIsolationWindow.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getLowerIsolationWindow", handle, function, scan);
      }
      return (float) mh$.invokeExact(handle, function, scan);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * float getUpperIsolationWindow(Handle handle, int32_t function, int32_t scan)
   *}
   */
  public static FunctionDescriptor getUpperIsolationWindow$descriptor() {
    return getUpperIsolationWindow.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * float getUpperIsolationWindow(Handle handle, int32_t function, int32_t scan)
   *}
   */
  public static MethodHandle getUpperIsolationWindow$handle() {
    return getUpperIsolationWindow.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * float getUpperIsolationWindow(Handle handle, int32_t function, int32_t scan)
   *}
   */
  public static MemorySegment getUpperIsolationWindow$address() {
    return getUpperIsolationWindow.ADDR;
  }

  /**
   * {@snippet lang = c:
   * float getUpperIsolationWindow(Handle handle, int32_t function, int32_t scan)
   *}
   */
  public static float getUpperIsolationWindow(MemorySegment handle, int function, int scan) {
    var mh$ = getUpperIsolationWindow.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getUpperIsolationWindow", handle, function, scan);
      }
      return (float) mh$.invokeExact(handle, function, scan);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * float getRT(Handle handle, int32_t function, int32_t scan)
   *}
   */
  public static FunctionDescriptor getRT$descriptor() {
    return getRT.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * float getRT(Handle handle, int32_t function, int32_t scan)
   *}
   */
  public static MethodHandle getRT$handle() {
    return getRT.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * float getRT(Handle handle, int32_t function, int32_t scan)
   *}
   */
  public static MemorySegment getRT$address() {
    return getRT.ADDR;
  }

  /**
   * {@snippet lang = c:
   * float getRT(Handle handle, int32_t function, int32_t scan)
   *}
   */
  public static float getRT(MemorySegment handle, int function, int scan) {
    var mh$ = getRT.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getRT", handle, function, scan);
      }
      return (float) mh$.invokeExact(handle, function, scan);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * void getScanInfo(Handle handle, int32_t function, int32_t scan, struct ScanInfo *pScanInfo)
   *}
   */
  public static FunctionDescriptor getScanInfo$descriptor() {
    return getScanInfo.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * void getScanInfo(Handle handle, int32_t function, int32_t scan, struct ScanInfo *pScanInfo)
   *}
   */
  public static MethodHandle getScanInfo$handle() {
    return getScanInfo.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * void getScanInfo(Handle handle, int32_t function, int32_t scan, struct ScanInfo *pScanInfo)
   *}
   */
  public static MemorySegment getScanInfo$address() {
    return getScanInfo.ADDR;
  }

  /**
   * {@snippet lang = c:
   * void getScanInfo(Handle handle, int32_t function, int32_t scan, struct ScanInfo *pScanInfo)
   *}
   */
  public static void getScanInfo(MemorySegment handle, int function, int scan,
      MemorySegment pScanInfo) {
    var mh$ = getScanInfo.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getScanInfo", handle, function, scan, pScanInfo);
      }
      mh$.invokeExact(handle, function, scan, pScanInfo);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * int32_t isRawSpectrumContinuum(Handle handle, int32_t function)
   *}
   */
  public static FunctionDescriptor isRawSpectrumContinuum$descriptor() {
    return isRawSpectrumContinuum.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * int32_t isRawSpectrumContinuum(Handle handle, int32_t function)
   *}
   */
  public static MethodHandle isRawSpectrumContinuum$handle() {
    return isRawSpectrumContinuum.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * int32_t isRawSpectrumContinuum(Handle handle, int32_t function)
   *}
   */
  public static MemorySegment isRawSpectrumContinuum$address() {
    return isRawSpectrumContinuum.ADDR;
  }

  /**
   * {@snippet lang = c:
   * int32_t isRawSpectrumContinuum(Handle handle, int32_t function)
   *}
   */
  public static int isRawSpectrumContinuum(MemorySegment handle, int function) {
    var mh$ = isRawSpectrumContinuum.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("isRawSpectrumContinuum", handle, function);
      }
      return (int) mh$.invokeExact(handle, function);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t isMsFunction(Handle handle, int32_t function)
   *}
   */
  public static FunctionDescriptor isMsFunction$descriptor() {
    return isMsFunction.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t isMsFunction(Handle handle, int32_t function)
   *}
   */
  public static MethodHandle isMsFunction$handle() {
    return isMsFunction.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t isMsFunction(Handle handle, int32_t function)
   *}
   */
  public static MemorySegment isMsFunction$address() {
    return isMsFunction.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t isMsFunction(Handle handle, int32_t function)
   *}
   */
  public static int isMsFunction(MemorySegment handle, int function) {
    var mh$ = isMsFunction.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("isMsFunction", handle, function);
      }
      return (int) mh$.invokeExact(handle, function);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t getDataPoints(Handle handle, int32_t function, int32_t scan, double *pMzBuffer, double *pIntensityBuffer, uint32_t bufferSizeInBytes)
   *}
   */
  public static FunctionDescriptor getDataPoints$descriptor() {
    return getDataPoints.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t getDataPoints(Handle handle, int32_t function, int32_t scan, double *pMzBuffer, double *pIntensityBuffer, uint32_t bufferSizeInBytes)
   *}
   */
  public static MethodHandle getDataPoints$handle() {
    return getDataPoints.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t getDataPoints(Handle handle, int32_t function, int32_t scan, double *pMzBuffer, double *pIntensityBuffer, uint32_t bufferSizeInBytes)
   *}
   */
  public static MemorySegment getDataPoints$address() {
    return getDataPoints.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t getDataPoints(Handle handle, int32_t function, int32_t scan, double *pMzBuffer, double *pIntensityBuffer, uint32_t bufferSizeInBytes)
   *}
   */
  public static int getDataPoints(MemorySegment handle, int function, int scan,
      MemorySegment pMzBuffer, MemorySegment pIntensityBuffer, int bufferSizeInBytes) {
    var mh$ = getDataPoints.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getDataPoints", handle, function, scan, pMzBuffer, pIntensityBuffer,
            bufferSizeInBytes);
      }
      return (int) mh$.invokeExact(handle, function, scan, pMzBuffer, pIntensityBuffer,
          bufferSizeInBytes);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t getMobilityScanDataPoints(Handle handle, int32_t function, int32_t scan, int32_t mobilityScan, double *pMzBuffer, double *pIntensityBuffer, uint32_t bufferSizeInBytes)
   *}
   */
  public static FunctionDescriptor getMobilityScanDataPoints$descriptor() {
    return getMobilityScanDataPoints.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t getMobilityScanDataPoints(Handle handle, int32_t function, int32_t scan, int32_t mobilityScan, double *pMzBuffer, double *pIntensityBuffer, uint32_t bufferSizeInBytes)
   *}
   */
  public static MethodHandle getMobilityScanDataPoints$handle() {
    return getMobilityScanDataPoints.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t getMobilityScanDataPoints(Handle handle, int32_t function, int32_t scan, int32_t mobilityScan, double *pMzBuffer, double *pIntensityBuffer, uint32_t bufferSizeInBytes)
   *}
   */
  public static MemorySegment getMobilityScanDataPoints$address() {
    return getMobilityScanDataPoints.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t getMobilityScanDataPoints(Handle handle, int32_t function, int32_t scan, int32_t mobilityScan, double *pMzBuffer, double *pIntensityBuffer, uint32_t bufferSizeInBytes)
   *}
   */
  public static int getMobilityScanDataPoints(MemorySegment handle, int function, int scan,
      int mobilityScan, MemorySegment pMzBuffer, MemorySegment pIntensityBuffer,
      int bufferSizeInBytes) {
    var mh$ = getMobilityScanDataPoints.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getMobilityScanDataPoints", handle, function, scan, mobilityScan, pMzBuffer,
            pIntensityBuffer, bufferSizeInBytes);
      }
      return (int) mh$.invokeExact(handle, function, scan, mobilityScan, pMzBuffer,
          pIntensityBuffer, bufferSizeInBytes);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t getRawMobilityScanDataPoints(Handle handle, int32_t function, int32_t scan, int32_t mobilityScan, double *pMzBuffer, double *pIntensityBuffer, uint32_t bufferSizeInBytes)
   *}
   */
  public static FunctionDescriptor getRawMobilityScanDataPoints$descriptor() {
    return getRawMobilityScanDataPoints.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t getRawMobilityScanDataPoints(Handle handle, int32_t function, int32_t scan, int32_t mobilityScan, double *pMzBuffer, double *pIntensityBuffer, uint32_t bufferSizeInBytes)
   *}
   */
  public static MethodHandle getRawMobilityScanDataPoints$handle() {
    return getRawMobilityScanDataPoints.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t getRawMobilityScanDataPoints(Handle handle, int32_t function, int32_t scan, int32_t mobilityScan, double *pMzBuffer, double *pIntensityBuffer, uint32_t bufferSizeInBytes)
   *}
   */
  public static MemorySegment getRawMobilityScanDataPoints$address() {
    return getRawMobilityScanDataPoints.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t getRawMobilityScanDataPoints(Handle handle, int32_t function, int32_t scan, int32_t mobilityScan, double *pMzBuffer, double *pIntensityBuffer, uint32_t bufferSizeInBytes)
   *}
   */
  public static int getRawMobilityScanDataPoints(MemorySegment handle, int function, int scan,
      int mobilityScan, MemorySegment pMzBuffer, MemorySegment pIntensityBuffer,
      int bufferSizeInBytes) {
    var mh$ = getRawMobilityScanDataPoints.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getRawMobilityScanDataPoints", handle, function, scan, mobilityScan,
            pMzBuffer, pIntensityBuffer, bufferSizeInBytes);
      }
      return (int) mh$.invokeExact(handle, function, scan, mobilityScan, pMzBuffer,
          pIntensityBuffer, bufferSizeInBytes);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * double getAcquisitionRangeStart(Handle handle, uint32_t function)
   *}
   */
  public static FunctionDescriptor getAcquisitionRangeStart$descriptor() {
    return getAcquisitionRangeStart.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * double getAcquisitionRangeStart(Handle handle, uint32_t function)
   *}
   */
  public static MethodHandle getAcquisitionRangeStart$handle() {
    return getAcquisitionRangeStart.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * double getAcquisitionRangeStart(Handle handle, uint32_t function)
   *}
   */
  public static MemorySegment getAcquisitionRangeStart$address() {
    return getAcquisitionRangeStart.ADDR;
  }

  /**
   * {@snippet lang = c:
   * double getAcquisitionRangeStart(Handle handle, uint32_t function)
   *}
   */
  public static double getAcquisitionRangeStart(MemorySegment handle, int function) {
    var mh$ = getAcquisitionRangeStart.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getAcquisitionRangeStart", handle, function);
      }
      return (double) mh$.invokeExact(handle, function);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * double getAcquisitionRangeEnd(Handle handle, uint32_t function)
   *}
   */
  public static FunctionDescriptor getAcquisitionRangeEnd$descriptor() {
    return getAcquisitionRangeEnd.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * double getAcquisitionRangeEnd(Handle handle, uint32_t function)
   *}
   */
  public static MethodHandle getAcquisitionRangeEnd$handle() {
    return getAcquisitionRangeEnd.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * double getAcquisitionRangeEnd(Handle handle, uint32_t function)
   *}
   */
  public static MemorySegment getAcquisitionRangeEnd$address() {
    return getAcquisitionRangeEnd.ADDR;
  }

  /**
   * {@snippet lang = c:
   * double getAcquisitionRangeEnd(Handle handle, uint32_t function)
   *}
   */
  public static double getAcquisitionRangeEnd(MemorySegment handle, int function) {
    var mh$ = getAcquisitionRangeEnd.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getAcquisitionRangeEnd", handle, function);
      }
      return (double) mh$.invokeExact(handle, function);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * int32_t getNumberOfMrmsInFunction(Handle handle, int32_t function)
   *}
   */
  public static FunctionDescriptor getNumberOfMrmsInFunction$descriptor() {
    return getNumberOfMrmsInFunction.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * int32_t getNumberOfMrmsInFunction(Handle handle, int32_t function)
   *}
   */
  public static MethodHandle getNumberOfMrmsInFunction$handle() {
    return getNumberOfMrmsInFunction.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * int32_t getNumberOfMrmsInFunction(Handle handle, int32_t function)
   *}
   */
  public static MemorySegment getNumberOfMrmsInFunction$address() {
    return getNumberOfMrmsInFunction.ADDR;
  }

  /**
   * {@snippet lang = c:
   * int32_t getNumberOfMrmsInFunction(Handle handle, int32_t function)
   *}
   */
  public static int getNumberOfMrmsInFunction(MemorySegment handle, int function) {
    var mh$ = getNumberOfMrmsInFunction.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getNumberOfMrmsInFunction", handle, function);
      }
      return (int) mh$.invokeExact(handle, function);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t getMrmDataPoints(Handle handle, int32_t function, int32_t mrm, float *rtBuffer, float *intensityBuffer, uint32_t bufferSizeInBytes)
   *}
   */
  public static FunctionDescriptor getMrmDataPoints$descriptor() {
    return getMrmDataPoints.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t getMrmDataPoints(Handle handle, int32_t function, int32_t mrm, float *rtBuffer, float *intensityBuffer, uint32_t bufferSizeInBytes)
   *}
   */
  public static MethodHandle getMrmDataPoints$handle() {
    return getMrmDataPoints.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t getMrmDataPoints(Handle handle, int32_t function, int32_t mrm, float *rtBuffer, float *intensityBuffer, uint32_t bufferSizeInBytes)
   *}
   */
  public static MemorySegment getMrmDataPoints$address() {
    return getMrmDataPoints.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t getMrmDataPoints(Handle handle, int32_t function, int32_t mrm, float *rtBuffer, float *intensityBuffer, uint32_t bufferSizeInBytes)
   *}
   */
  public static int getMrmDataPoints(MemorySegment handle, int function, int mrm,
      MemorySegment rtBuffer, MemorySegment intensityBuffer, int bufferSizeInBytes) {
    var mh$ = getMrmDataPoints.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getMrmDataPoints", handle, function, mrm, rtBuffer, intensityBuffer,
            bufferSizeInBytes);
      }
      return (int) mh$.invokeExact(handle, function, mrm, rtBuffer, intensityBuffer,
          bufferSizeInBytes);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * float getMrmQ1Mass(Handle handle, int32_t function, int32_t mrm)
   *}
   */
  public static FunctionDescriptor getMrmQ1Mass$descriptor() {
    return getMrmQ1Mass.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * float getMrmQ1Mass(Handle handle, int32_t function, int32_t mrm)
   *}
   */
  public static MethodHandle getMrmQ1Mass$handle() {
    return getMrmQ1Mass.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * float getMrmQ1Mass(Handle handle, int32_t function, int32_t mrm)
   *}
   */
  public static MemorySegment getMrmQ1Mass$address() {
    return getMrmQ1Mass.ADDR;
  }

  /**
   * {@snippet lang = c:
   * float getMrmQ1Mass(Handle handle, int32_t function, int32_t mrm)
   *}
   */
  public static float getMrmQ1Mass(MemorySegment handle, int function, int mrm) {
    var mh$ = getMrmQ1Mass.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getMrmQ1Mass", handle, function, mrm);
      }
      return (float) mh$.invokeExact(handle, function, mrm);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * float getMrmQ3Mass(Handle handle, int32_t function, int32_t mrm)
   *}
   */
  public static FunctionDescriptor getMrmQ3Mass$descriptor() {
    return getMrmQ3Mass.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * float getMrmQ3Mass(Handle handle, int32_t function, int32_t mrm)
   *}
   */
  public static MethodHandle getMrmQ3Mass$handle() {
    return getMrmQ3Mass.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * float getMrmQ3Mass(Handle handle, int32_t function, int32_t mrm)
   *}
   */
  public static MemorySegment getMrmQ3Mass$address() {
    return getMrmQ3Mass.ADDR;
  }

  /**
   * {@snippet lang = c:
   * float getMrmQ3Mass(Handle handle, int32_t function, int32_t mrm)
   *}
   */
  public static float getMrmQ3Mass(MemorySegment handle, int function, int mrm) {
    var mh$ = getMrmQ3Mass.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getMrmQ3Mass", handle, function, mrm);
      }
      return (float) mh$.invokeExact(handle, function, mrm);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * int32_t getAnalogChannelCount(Handle handle)
   *}
   */
  public static FunctionDescriptor getAnalogChannelCount$descriptor() {
    return getAnalogChannelCount.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * int32_t getAnalogChannelCount(Handle handle)
   *}
   */
  public static MethodHandle getAnalogChannelCount$handle() {
    return getAnalogChannelCount.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * int32_t getAnalogChannelCount(Handle handle)
   *}
   */
  public static MemorySegment getAnalogChannelCount$address() {
    return getAnalogChannelCount.ADDR;
  }

  /**
   * {@snippet lang = c:
   * int32_t getAnalogChannelCount(Handle handle)
   *}
   */
  public static int getAnalogChannelCount(MemorySegment handle) {
    var mh$ = getAnalogChannelCount.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getAnalogChannelCount", handle);
      }
      return (int) mh$.invokeExact(handle);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * uint32_t getAnalogDataPoints(Handle handle, int32_t channel, float *rtBuffer, float *intensityBuffer, uint32_t bufferSizeInBytes)
   *}
   */
  public static FunctionDescriptor getAnalogDataPoints$descriptor() {
    return getAnalogDataPoints.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * uint32_t getAnalogDataPoints(Handle handle, int32_t channel, float *rtBuffer, float *intensityBuffer, uint32_t bufferSizeInBytes)
   *}
   */
  public static MethodHandle getAnalogDataPoints$handle() {
    return getAnalogDataPoints.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * uint32_t getAnalogDataPoints(Handle handle, int32_t channel, float *rtBuffer, float *intensityBuffer, uint32_t bufferSizeInBytes)
   *}
   */
  public static MemorySegment getAnalogDataPoints$address() {
    return getAnalogDataPoints.ADDR;
  }

  /**
   * {@snippet lang = c:
   * uint32_t getAnalogDataPoints(Handle handle, int32_t channel, float *rtBuffer, float *intensityBuffer, uint32_t bufferSizeInBytes)
   *}
   */
  public static int getAnalogDataPoints(MemorySegment handle, int channel, MemorySegment rtBuffer,
      MemorySegment intensityBuffer, int bufferSizeInBytes) {
    var mh$ = getAnalogDataPoints.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getAnalogDataPoints", handle, channel, rtBuffer, intensityBuffer,
            bufferSizeInBytes);
      }
      return (int) mh$.invokeExact(handle, channel, rtBuffer, intensityBuffer, bufferSizeInBytes);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * int32_t getAnalogChannelUnits(Handle handle, int32_t channel, char *buffer, int32_t bufferSizeInBytes)
   *}
   */
  public static FunctionDescriptor getAnalogChannelUnits$descriptor() {
    return getAnalogChannelUnits.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * int32_t getAnalogChannelUnits(Handle handle, int32_t channel, char *buffer, int32_t bufferSizeInBytes)
   *}
   */
  public static MethodHandle getAnalogChannelUnits$handle() {
    return getAnalogChannelUnits.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * int32_t getAnalogChannelUnits(Handle handle, int32_t channel, char *buffer, int32_t bufferSizeInBytes)
   *}
   */
  public static MemorySegment getAnalogChannelUnits$address() {
    return getAnalogChannelUnits.ADDR;
  }

  /**
   * {@snippet lang = c:
   * int32_t getAnalogChannelUnits(Handle handle, int32_t channel, char *buffer, int32_t bufferSizeInBytes)
   *}
   */
  public static int getAnalogChannelUnits(MemorySegment handle, int channel, MemorySegment buffer,
      int bufferSizeInBytes) {
    var mh$ = getAnalogChannelUnits.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getAnalogChannelUnits", handle, channel, buffer, bufferSizeInBytes);
      }
      return (int) mh$.invokeExact(handle, channel, buffer, bufferSizeInBytes);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * Function descriptor for:
   * {@snippet lang = c:
   * int32_t getAnalogChannelDescription(Handle handle, int32_t channel, char *buffer, int32_t bufferSizeInBytes)
   *}
   */
  public static FunctionDescriptor getAnalogChannelDescription$descriptor() {
    return getAnalogChannelDescription.DESC;
  }

  /**
   * Downcall method handle for:
   * {@snippet lang = c:
   * int32_t getAnalogChannelDescription(Handle handle, int32_t channel, char *buffer, int32_t bufferSizeInBytes)
   *}
   */
  public static MethodHandle getAnalogChannelDescription$handle() {
    return getAnalogChannelDescription.HANDLE;
  }

  /**
   * Address for:
   * {@snippet lang = c:
   * int32_t getAnalogChannelDescription(Handle handle, int32_t channel, char *buffer, int32_t bufferSizeInBytes)
   *}
   */
  public static MemorySegment getAnalogChannelDescription$address() {
    return getAnalogChannelDescription.ADDR;
  }

  /**
   * {@snippet lang = c:
   * int32_t getAnalogChannelDescription(Handle handle, int32_t channel, char *buffer, int32_t bufferSizeInBytes)
   *}
   */
  public static int getAnalogChannelDescription(MemorySegment handle, int channel,
      MemorySegment buffer, int bufferSizeInBytes) {
    var mh$ = getAnalogChannelDescription.HANDLE;
    try {
      if (TRACE_DOWNCALLS) {
        traceDowncall("getAnalogChannelDescription", handle, channel, buffer, bufferSizeInBytes);
      }
      return (int) mh$.invokeExact(handle, channel, buffer, bufferSizeInBytes);
    } catch (Throwable ex$) {
      throw new AssertionError("should not reach here", ex$);
    }
  }

  /**
   * {@snippet lang = c:
   * #define _VCRUNTIME_DISABLED_WARNINGS 4514
   *}
   */
  public static int _VCRUNTIME_DISABLED_WARNINGS() {
    return _VCRUNTIME_DISABLED_WARNINGS;
  }

  /**
   * {@snippet lang = c:
   * #define NULL (void*) 0
   *}
   */
  public static MemorySegment NULL() {
    return NULL;
  }

  /**
   * {@snippet lang = c:
   * #define INT8_MIN -128
   *}
   */
  public static int INT8_MIN() {
    return INT8_MIN;
  }

  /**
   * {@snippet lang = c:
   * #define INT16_MIN -32768
   *}
   */
  public static int INT16_MIN() {
    return INT16_MIN;
  }

  /**
   * {@snippet lang = c:
   * #define INT32_MIN -2147483648
   *}
   */
  public static int INT32_MIN() {
    return INT32_MIN;
  }

  /**
   * {@snippet lang = c:
   * #define INT64_MIN -9223372036854775808
   *}
   */
  public static long INT64_MIN() {
    return INT64_MIN;
  }

  /**
   * {@snippet lang = c:
   * #define INT8_MAX 127
   *}
   */
  public static byte INT8_MAX() {
    return INT8_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define INT16_MAX 32767
   *}
   */
  public static short INT16_MAX() {
    return INT16_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define INT32_MAX 2147483647
   *}
   */
  public static int INT32_MAX() {
    return INT32_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define INT64_MAX 9223372036854775807
   *}
   */
  public static long INT64_MAX() {
    return INT64_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define UINT8_MAX 255
   *}
   */
  public static byte UINT8_MAX() {
    return UINT8_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define UINT16_MAX 65535
   *}
   */
  public static short UINT16_MAX() {
    return UINT16_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define UINT32_MAX 4294967295
   *}
   */
  public static int UINT32_MAX() {
    return UINT32_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define UINT64_MAX -1
   *}
   */
  public static long UINT64_MAX() {
    return UINT64_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define INT_LEAST8_MIN -128
   *}
   */
  public static int INT_LEAST8_MIN() {
    return INT_LEAST8_MIN;
  }

  /**
   * {@snippet lang = c:
   * #define INT_LEAST16_MIN -32768
   *}
   */
  public static int INT_LEAST16_MIN() {
    return INT_LEAST16_MIN;
  }

  /**
   * {@snippet lang = c:
   * #define INT_LEAST32_MIN -2147483648
   *}
   */
  public static int INT_LEAST32_MIN() {
    return INT_LEAST32_MIN;
  }

  /**
   * {@snippet lang = c:
   * #define INT_LEAST64_MIN -9223372036854775808
   *}
   */
  public static long INT_LEAST64_MIN() {
    return INT_LEAST64_MIN;
  }

  /**
   * {@snippet lang = c:
   * #define INT_LEAST8_MAX 127
   *}
   */
  public static byte INT_LEAST8_MAX() {
    return INT_LEAST8_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define INT_LEAST16_MAX 32767
   *}
   */
  public static short INT_LEAST16_MAX() {
    return INT_LEAST16_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define INT_LEAST32_MAX 2147483647
   *}
   */
  public static int INT_LEAST32_MAX() {
    return INT_LEAST32_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define INT_LEAST64_MAX 9223372036854775807
   *}
   */
  public static long INT_LEAST64_MAX() {
    return INT_LEAST64_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define UINT_LEAST8_MAX 255
   *}
   */
  public static byte UINT_LEAST8_MAX() {
    return UINT_LEAST8_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define UINT_LEAST16_MAX 65535
   *}
   */
  public static short UINT_LEAST16_MAX() {
    return UINT_LEAST16_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define UINT_LEAST32_MAX 4294967295
   *}
   */
  public static int UINT_LEAST32_MAX() {
    return UINT_LEAST32_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define UINT_LEAST64_MAX -1
   *}
   */
  public static long UINT_LEAST64_MAX() {
    return UINT_LEAST64_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define INT_FAST8_MIN -128
   *}
   */
  public static int INT_FAST8_MIN() {
    return INT_FAST8_MIN;
  }

  /**
   * {@snippet lang = c:
   * #define INT_FAST16_MIN -2147483648
   *}
   */
  public static int INT_FAST16_MIN() {
    return INT_FAST16_MIN;
  }

  /**
   * {@snippet lang = c:
   * #define INT_FAST32_MIN -2147483648
   *}
   */
  public static int INT_FAST32_MIN() {
    return INT_FAST32_MIN;
  }

  /**
   * {@snippet lang = c:
   * #define INT_FAST64_MIN -9223372036854775808
   *}
   */
  public static long INT_FAST64_MIN() {
    return INT_FAST64_MIN;
  }

  /**
   * {@snippet lang = c:
   * #define INT_FAST8_MAX 127
   *}
   */
  public static byte INT_FAST8_MAX() {
    return INT_FAST8_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define INT_FAST16_MAX 2147483647
   *}
   */
  public static int INT_FAST16_MAX() {
    return INT_FAST16_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define INT_FAST32_MAX 2147483647
   *}
   */
  public static int INT_FAST32_MAX() {
    return INT_FAST32_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define INT_FAST64_MAX 9223372036854775807
   *}
   */
  public static long INT_FAST64_MAX() {
    return INT_FAST64_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define UINT_FAST8_MAX 255
   *}
   */
  public static byte UINT_FAST8_MAX() {
    return UINT_FAST8_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define UINT_FAST16_MAX 4294967295
   *}
   */
  public static int UINT_FAST16_MAX() {
    return UINT_FAST16_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define UINT_FAST32_MAX 4294967295
   *}
   */
  public static int UINT_FAST32_MAX() {
    return UINT_FAST32_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define UINT_FAST64_MAX -1
   *}
   */
  public static long UINT_FAST64_MAX() {
    return UINT_FAST64_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define INTPTR_MIN -9223372036854775808
   *}
   */
  public static long INTPTR_MIN() {
    return INTPTR_MIN;
  }

  /**
   * {@snippet lang = c:
   * #define INTPTR_MAX 9223372036854775807
   *}
   */
  public static long INTPTR_MAX() {
    return INTPTR_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define UINTPTR_MAX -1
   *}
   */
  public static long UINTPTR_MAX() {
    return UINTPTR_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define INTMAX_MIN -9223372036854775808
   *}
   */
  public static long INTMAX_MIN() {
    return INTMAX_MIN;
  }

  /**
   * {@snippet lang = c:
   * #define INTMAX_MAX 9223372036854775807
   *}
   */
  public static long INTMAX_MAX() {
    return INTMAX_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define UINTMAX_MAX -1
   *}
   */
  public static long UINTMAX_MAX() {
    return UINTMAX_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define PTRDIFF_MIN -9223372036854775808
   *}
   */
  public static long PTRDIFF_MIN() {
    return PTRDIFF_MIN;
  }

  /**
   * {@snippet lang = c:
   * #define PTRDIFF_MAX 9223372036854775807
   *}
   */
  public static long PTRDIFF_MAX() {
    return PTRDIFF_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define SIZE_MAX -1
   *}
   */
  public static long SIZE_MAX() {
    return SIZE_MAX;
  }

  /**
   * {@snippet lang = c:
   * #define SIG_ATOMIC_MIN -2147483648
   *}
   */
  public static int SIG_ATOMIC_MIN() {
    return SIG_ATOMIC_MIN;
  }

  /**
   * {@snippet lang = c:
   * #define SIG_ATOMIC_MAX 2147483647
   *}
   */
  public static int SIG_ATOMIC_MAX() {
    return SIG_ATOMIC_MAX;
  }

  /**
   * Variadic invoker class for:
   * {@snippet lang = c:
   * void __va_start(va_list *, ...)
   *}
   */
  public static class __va_start {

    private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
        MassLynxLib.C_POINTER);
    private static final MemorySegment ADDR = MassLynxLib.findOrThrow("__va_start");

    private final MethodHandle handle;
    private final FunctionDescriptor descriptor;
    private final MethodHandle spreader;

    private __va_start(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
      this.handle = handle;
      this.descriptor = descriptor;
      this.spreader = spreader;
    }

    /**
     * Variadic invoker factory for:
     * {@snippet lang = c:
     * void __va_start(va_list *, ...)
     *}
     */
    public static __va_start makeInvoker(MemoryLayout... layouts) {
      FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
      Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
      var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
      var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
      return new __va_start(mh$, desc$, spreader$);
    }

    /**
     * {@return the address}
     */
    public static MemorySegment address() {
      return ADDR;
    }

    /**
     * {@return the specialized method handle}
     */
    public MethodHandle handle() {
      return handle;
    }

    /**
     * {@return the specialized descriptor}
     */
    public FunctionDescriptor descriptor() {
      return descriptor;
    }

    public void apply(MemorySegment x0, Object... x1) {
      try {
        if (TRACE_DOWNCALLS) {
          traceDowncall("__va_start", x0, x1);
        }
        spreader.invokeExact(x0, x1);
      } catch (IllegalArgumentException | ClassCastException ex$) {
        throw ex$; // rethrow IAE from passing wrong number/type of args
      } catch (Throwable ex$) {
        throw new AssertionError("should not reach here", ex$);
      }
    }
  }

  private static class __security_init_cookie {

    public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid();

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("__security_init_cookie");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class __security_check_cookie {

    public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
        MassLynxLib.C_LONG_LONG);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("__security_check_cookie");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class __report_gsfailure {

    public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
        MassLynxLib.C_LONG_LONG);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("__report_gsfailure");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class __security_cookie$constants {

    public static final OfLong LAYOUT = MassLynxLib.C_LONG_LONG;
    public static final MemorySegment SEGMENT = MassLynxLib.findOrThrow("__security_cookie")
        .reinterpret(LAYOUT.byteSize());
  }

  private static class DEFAULT_FLOAT$constants {

    public static final OfFloat LAYOUT = MassLynxLib.C_FLOAT;
    public static final MemorySegment SEGMENT = MassLynxLib.findOrThrow("DEFAULT_FLOAT")
        .reinterpret(LAYOUT.byteSize());
  }

  private static class DEFAULT_INT$constants {

    public static final OfInt LAYOUT = MassLynxLib.C_INT;
    public static final MemorySegment SEGMENT = MassLynxLib.findOrThrow("DEFAULT_INT")
        .reinterpret(LAYOUT.byteSize());
  }

  private static class NO_PRECURSOR$constants {

    public static final OfFloat LAYOUT = MassLynxLib.C_FLOAT;
    public static final MemorySegment SEGMENT = MassLynxLib.findOrThrow("NO_PRECURSOR")
        .reinterpret(LAYOUT.byteSize());
  }

  private static class NO_QUAD_ISOLATION$constants {

    public static final OfFloat LAYOUT = MassLynxLib.C_FLOAT;
    public static final MemorySegment SEGMENT = MassLynxLib.findOrThrow("NO_QUAD_ISOLATION")
        .reinterpret(LAYOUT.byteSize());
  }

  private static class NO_COLLISION_ENERGY$constants {

    public static final OfFloat LAYOUT = MassLynxLib.C_FLOAT;
    public static final MemorySegment SEGMENT = MassLynxLib.findOrThrow("NO_COLLISION_ENERGY")
        .reinterpret(LAYOUT.byteSize());
  }

  private static class NO_MOBILITY$constants {

    public static final OfFloat LAYOUT = MassLynxLib.C_FLOAT;
    public static final MemorySegment SEGMENT = MassLynxLib.findOrThrow("NO_MOBILITY")
        .reinterpret(LAYOUT.byteSize());
  }

  private static class NO_POSITION$constants {

    public static final OfFloat LAYOUT = MassLynxLib.C_FLOAT;
    public static final MemorySegment SEGMENT = MassLynxLib.findOrThrow("NO_POSITION")
        .reinterpret(LAYOUT.byteSize());
  }

  private static class NO_DRIFT_SCANS$constants {

    public static final OfInt LAYOUT = MassLynxLib.C_INT;
    public static final MemorySegment SEGMENT = MassLynxLib.findOrThrow("NO_DRIFT_SCANS")
        .reinterpret(LAYOUT.byteSize());
  }

  private static class NO_LOCKMASS_FUNCTION$constants {

    public static final OfInt LAYOUT = MassLynxLib.C_INT;
    public static final MemorySegment SEGMENT = MassLynxLib.findOrThrow("NO_LOCKMASS_FUNCTION")
        .reinterpret(LAYOUT.byteSize());
  }

  private static class NO_PROFILE_INFORMATION$constants {

    public static final OfInt LAYOUT = MassLynxLib.C_INT;
    public static final MemorySegment SEGMENT = MassLynxLib.findOrThrow("NO_PROFILE_INFORMATION")
        .reinterpret(LAYOUT.byteSize());
  }

  private static class NO_RT$constants {

    public static final OfFloat LAYOUT = MassLynxLib.C_FLOAT;
    public static final MemorySegment SEGMENT = MassLynxLib.findOrThrow("NO_RT")
        .reinterpret(LAYOUT.byteSize());
  }

  private static class openFile {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_POINTER,
        MassLynxLib.C_POINTER);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("openFile");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class closeFile {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("closeFile");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getAcquisitionDate {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER, MassLynxLib.C_POINTER, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getAcquisitionDate");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class setCentroid {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("setCentroid");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class applyAutoLockmassCorrection {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("applyAutoLockmassCorrection");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class isLockMassCorrected {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("isLockMassCorrected");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class applyCustomLockmassCorrection {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER, MassLynxLib.C_FLOAT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow(
        "applyCustomLockmassCorrection");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getNumberOfScans {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getNumberOfScans");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getNumberOfScansInFunction {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getNumberOfScansInFunction");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getNumberOfFunctions {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getNumberOfFunctions");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getMsLevel {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getMsLevel");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getLockmassFunction {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getLockmassFunction");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class isIonMobilityFile {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("isIonMobilityFile");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getNumberOfMobilityScans {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getNumberOfMobilityScans");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class isIonMobilityFunction {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("isIonMobilityFunction");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class isDdaFile {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("isDdaFile");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class isImagingFile {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("isImagingFile");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class setAbsoluteThreshold {

    public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(MassLynxLib.C_POINTER,
        MassLynxLib.C_FLOAT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("setAbsoluteThreshold");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getPolarity {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getPolarity");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getPrecursorMz {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_FLOAT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getPrecursorMz");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getMobility {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_FLOAT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getMobility");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getLowerIsolationWindow {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_FLOAT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getLowerIsolationWindow");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getUpperIsolationWindow {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_FLOAT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getUpperIsolationWindow");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getRT {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_FLOAT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getRT");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getScanInfo {

    public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(MassLynxLib.C_POINTER,
        MassLynxLib.C_INT, MassLynxLib.C_INT, MassLynxLib.C_POINTER);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getScanInfo");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class isRawSpectrumContinuum {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("isRawSpectrumContinuum");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class isMsFunction {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("isMsFunction");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getDataPoints {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT, MassLynxLib.C_INT, MassLynxLib.C_POINTER,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getDataPoints");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getMobilityScanDataPoints {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT, MassLynxLib.C_INT, MassLynxLib.C_INT,
        MassLynxLib.C_POINTER, MassLynxLib.C_POINTER, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getMobilityScanDataPoints");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getRawMobilityScanDataPoints {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT, MassLynxLib.C_INT, MassLynxLib.C_INT,
        MassLynxLib.C_POINTER, MassLynxLib.C_POINTER, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow(
        "getRawMobilityScanDataPoints");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getAcquisitionRangeStart {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_DOUBLE,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getAcquisitionRangeStart");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getAcquisitionRangeEnd {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_DOUBLE,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getAcquisitionRangeEnd");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getNumberOfMrmsInFunction {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getNumberOfMrmsInFunction");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getMrmDataPoints {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT, MassLynxLib.C_INT, MassLynxLib.C_POINTER,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getMrmDataPoints");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getMrmQ1Mass {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_FLOAT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getMrmQ1Mass");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getMrmQ3Mass {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_FLOAT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getMrmQ3Mass");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getAnalogChannelCount {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getAnalogChannelCount");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getAnalogDataPoints {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT, MassLynxLib.C_POINTER, MassLynxLib.C_POINTER,
        MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getAnalogDataPoints");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getAnalogChannelUnits {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT, MassLynxLib.C_POINTER, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getAnalogChannelUnits");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }

  private static class getAnalogChannelDescription {

    public static final FunctionDescriptor DESC = FunctionDescriptor.of(MassLynxLib.C_INT,
        MassLynxLib.C_POINTER, MassLynxLib.C_INT, MassLynxLib.C_POINTER, MassLynxLib.C_INT);

    public static final MemorySegment ADDR = MassLynxLib.findOrThrow("getAnalogChannelDescription");

    public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
  }
}

