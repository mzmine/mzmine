/*
 * Copyright (c) 2004-2025 The mzmine Development Team
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

// Generated by jextract
package io.github.mzmine.modules.io.import_rawdata_masslynx;


import java.lang.foreign.*;
import java.util.function.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang = c:
 * struct ScanInfo {
 *     int32_t msLevel;
 *     int32_t polarity;
 *     int32_t driftScanCount;
 *     int32_t isProfile;
 *     float precursorMz;
 *     float quadIsolationStart;
 *     float quadIsolationEnd;
 *     float collisionEnergy;
 *     float rt;
 *     float laserXPos;
 *     float laserYPos;
 * }
 *}
 */
public class ScanInfo {

  private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
          MassLynxLib.C_INT.withName("msLevel"), MassLynxLib.C_INT.withName("polarity"),
          MassLynxLib.C_INT.withName("driftScanCount"), MassLynxLib.C_INT.withName("isProfile"),
          MassLynxLib.C_FLOAT.withName("precursorMz"),
          MassLynxLib.C_FLOAT.withName("quadIsolationStart"),
          MassLynxLib.C_FLOAT.withName("quadIsolationEnd"),
          MassLynxLib.C_FLOAT.withName("collisionEnergy"), MassLynxLib.C_FLOAT.withName("rt"),
          MassLynxLib.C_FLOAT.withName("laserXPos"), MassLynxLib.C_FLOAT.withName("laserYPos"))
      .withName("ScanInfo");
  private static final OfInt msLevel$LAYOUT = (OfInt) $LAYOUT.select(groupElement("msLevel"));
  private static final long msLevel$OFFSET = 0;
  private static final OfInt polarity$LAYOUT = (OfInt) $LAYOUT.select(groupElement("polarity"));
  private static final long polarity$OFFSET = 4;
  private static final OfInt driftScanCount$LAYOUT = (OfInt) $LAYOUT.select(
      groupElement("driftScanCount"));
  private static final long driftScanCount$OFFSET = 8;
  private static final OfInt isProfile$LAYOUT = (OfInt) $LAYOUT.select(groupElement("isProfile"));
  private static final long isProfile$OFFSET = 12;
  private static final OfFloat precursorMz$LAYOUT = (OfFloat) $LAYOUT.select(
      groupElement("precursorMz"));
  private static final long precursorMz$OFFSET = 16;
  private static final OfFloat quadIsolationStart$LAYOUT = (OfFloat) $LAYOUT.select(
      groupElement("quadIsolationStart"));
  private static final long quadIsolationStart$OFFSET = 20;
  private static final OfFloat quadIsolationEnd$LAYOUT = (OfFloat) $LAYOUT.select(
      groupElement("quadIsolationEnd"));
  private static final long quadIsolationEnd$OFFSET = 24;
  private static final OfFloat collisionEnergy$LAYOUT = (OfFloat) $LAYOUT.select(
      groupElement("collisionEnergy"));
  private static final long collisionEnergy$OFFSET = 28;
  private static final OfFloat rt$LAYOUT = (OfFloat) $LAYOUT.select(groupElement("rt"));
  private static final long rt$OFFSET = 32;
  private static final OfFloat laserXPos$LAYOUT = (OfFloat) $LAYOUT.select(
      groupElement("laserXPos"));
  private static final long laserXPos$OFFSET = 36;
  private static final OfFloat laserYPos$LAYOUT = (OfFloat) $LAYOUT.select(
      groupElement("laserYPos"));
  private static final long laserYPos$OFFSET = 40;

  ScanInfo() {
    // Should not be called directly
  }

  /**
   * The layout of this struct
   */
  public static final GroupLayout layout() {
    return $LAYOUT;
  }

  /**
   * Layout for field:
   * {@snippet lang = c:
   * int32_t msLevel
   *}
   */
  public static final OfInt msLevel$layout() {
    return msLevel$LAYOUT;
  }

  /**
   * Offset for field:
   * {@snippet lang = c:
   * int32_t msLevel
   *}
   */
  public static final long msLevel$offset() {
    return msLevel$OFFSET;
  }

  /**
   * Getter for field:
   * {@snippet lang = c:
   * int32_t msLevel
   *}
   */
  public static int msLevel(MemorySegment struct) {
    return struct.get(msLevel$LAYOUT, msLevel$OFFSET);
  }

  /**
   * Setter for field:
   * {@snippet lang = c:
   * int32_t msLevel
   *}
   */
  public static void msLevel(MemorySegment struct, int fieldValue) {
    struct.set(msLevel$LAYOUT, msLevel$OFFSET, fieldValue);
  }

  /**
   * Layout for field:
   * {@snippet lang = c:
   * int32_t polarity
   *}
   */
  public static final OfInt polarity$layout() {
    return polarity$LAYOUT;
  }

  /**
   * Offset for field:
   * {@snippet lang = c:
   * int32_t polarity
   *}
   */
  public static final long polarity$offset() {
    return polarity$OFFSET;
  }

  /**
   * Getter for field:
   * {@snippet lang = c:
   * int32_t polarity
   *}
   */
  public static int polarity(MemorySegment struct) {
    return struct.get(polarity$LAYOUT, polarity$OFFSET);
  }

  /**
   * Setter for field:
   * {@snippet lang = c:
   * int32_t polarity
   *}
   */
  public static void polarity(MemorySegment struct, int fieldValue) {
    struct.set(polarity$LAYOUT, polarity$OFFSET, fieldValue);
  }

  /**
   * Layout for field:
   * {@snippet lang = c:
   * int32_t driftScanCount
   *}
   */
  public static final OfInt driftScanCount$layout() {
    return driftScanCount$LAYOUT;
  }

  /**
   * Offset for field:
   * {@snippet lang = c:
   * int32_t driftScanCount
   *}
   */
  public static final long driftScanCount$offset() {
    return driftScanCount$OFFSET;
  }

  /**
   * Getter for field:
   * {@snippet lang = c:
   * int32_t driftScanCount
   *}
   */
  public static int driftScanCount(MemorySegment struct) {
    return struct.get(driftScanCount$LAYOUT, driftScanCount$OFFSET);
  }

  /**
   * Setter for field:
   * {@snippet lang = c:
   * int32_t driftScanCount
   *}
   */
  public static void driftScanCount(MemorySegment struct, int fieldValue) {
    struct.set(driftScanCount$LAYOUT, driftScanCount$OFFSET, fieldValue);
  }

  /**
   * Layout for field:
   * {@snippet lang = c:
   * int32_t isProfile
   *}
   */
  public static final OfInt isProfile$layout() {
    return isProfile$LAYOUT;
  }

  /**
   * Offset for field:
   * {@snippet lang = c:
   * int32_t isProfile
   *}
   */
  public static final long isProfile$offset() {
    return isProfile$OFFSET;
  }

  /**
   * Getter for field:
   * {@snippet lang = c:
   * int32_t isProfile
   *}
   */
  public static int isProfile(MemorySegment struct) {
    return struct.get(isProfile$LAYOUT, isProfile$OFFSET);
  }

  /**
   * Setter for field:
   * {@snippet lang = c:
   * int32_t isProfile
   *}
   */
  public static void isProfile(MemorySegment struct, int fieldValue) {
    struct.set(isProfile$LAYOUT, isProfile$OFFSET, fieldValue);
  }

  /**
   * Layout for field:
   * {@snippet lang = c:
   * float precursorMz
   *}
   */
  public static final OfFloat precursorMz$layout() {
    return precursorMz$LAYOUT;
  }

  /**
   * Offset for field:
   * {@snippet lang = c:
   * float precursorMz
   *}
   */
  public static final long precursorMz$offset() {
    return precursorMz$OFFSET;
  }

  /**
   * Getter for field:
   * {@snippet lang = c:
   * float precursorMz
   *}
   */
  public static float precursorMz(MemorySegment struct) {
    return struct.get(precursorMz$LAYOUT, precursorMz$OFFSET);
  }

  /**
   * Setter for field:
   * {@snippet lang = c:
   * float precursorMz
   *}
   */
  public static void precursorMz(MemorySegment struct, float fieldValue) {
    struct.set(precursorMz$LAYOUT, precursorMz$OFFSET, fieldValue);
  }

  /**
   * Layout for field:
   * {@snippet lang = c:
   * float quadIsolationStart
   *}
   */
  public static final OfFloat quadIsolationStart$layout() {
    return quadIsolationStart$LAYOUT;
  }

  /**
   * Offset for field:
   * {@snippet lang = c:
   * float quadIsolationStart
   *}
   */
  public static final long quadIsolationStart$offset() {
    return quadIsolationStart$OFFSET;
  }

  /**
   * Getter for field:
   * {@snippet lang = c:
   * float quadIsolationStart
   *}
   */
  public static float quadIsolationStart(MemorySegment struct) {
    return struct.get(quadIsolationStart$LAYOUT, quadIsolationStart$OFFSET);
  }

  /**
   * Setter for field:
   * {@snippet lang = c:
   * float quadIsolationStart
   *}
   */
  public static void quadIsolationStart(MemorySegment struct, float fieldValue) {
    struct.set(quadIsolationStart$LAYOUT, quadIsolationStart$OFFSET, fieldValue);
  }

  /**
   * Layout for field:
   * {@snippet lang = c:
   * float quadIsolationEnd
   *}
   */
  public static final OfFloat quadIsolationEnd$layout() {
    return quadIsolationEnd$LAYOUT;
  }

  /**
   * Offset for field:
   * {@snippet lang = c:
   * float quadIsolationEnd
   *}
   */
  public static final long quadIsolationEnd$offset() {
    return quadIsolationEnd$OFFSET;
  }

  /**
   * Getter for field:
   * {@snippet lang = c:
   * float quadIsolationEnd
   *}
   */
  public static float quadIsolationEnd(MemorySegment struct) {
    return struct.get(quadIsolationEnd$LAYOUT, quadIsolationEnd$OFFSET);
  }

  /**
   * Setter for field:
   * {@snippet lang = c:
   * float quadIsolationEnd
   *}
   */
  public static void quadIsolationEnd(MemorySegment struct, float fieldValue) {
    struct.set(quadIsolationEnd$LAYOUT, quadIsolationEnd$OFFSET, fieldValue);
  }

  /**
   * Layout for field:
   * {@snippet lang = c:
   * float collisionEnergy
   *}
   */
  public static final OfFloat collisionEnergy$layout() {
    return collisionEnergy$LAYOUT;
  }

  /**
   * Offset for field:
   * {@snippet lang = c:
   * float collisionEnergy
   *}
   */
  public static final long collisionEnergy$offset() {
    return collisionEnergy$OFFSET;
  }

  /**
   * Getter for field:
   * {@snippet lang = c:
   * float collisionEnergy
   *}
   */
  public static float collisionEnergy(MemorySegment struct) {
    return struct.get(collisionEnergy$LAYOUT, collisionEnergy$OFFSET);
  }

  /**
   * Setter for field:
   * {@snippet lang = c:
   * float collisionEnergy
   *}
   */
  public static void collisionEnergy(MemorySegment struct, float fieldValue) {
    struct.set(collisionEnergy$LAYOUT, collisionEnergy$OFFSET, fieldValue);
  }

  /**
   * Layout for field:
   * {@snippet lang = c:
   * float rt
   *}
   */
  public static final OfFloat rt$layout() {
    return rt$LAYOUT;
  }

  /**
   * Offset for field:
   * {@snippet lang = c:
   * float rt
   *}
   */
  public static final long rt$offset() {
    return rt$OFFSET;
  }

  /**
   * Getter for field:
   * {@snippet lang = c:
   * float rt
   *}
   */
  public static float rt(MemorySegment struct) {
    return struct.get(rt$LAYOUT, rt$OFFSET);
  }

  /**
   * Setter for field:
   * {@snippet lang = c:
   * float rt
   *}
   */
  public static void rt(MemorySegment struct, float fieldValue) {
    struct.set(rt$LAYOUT, rt$OFFSET, fieldValue);
  }

  /**
   * Layout for field:
   * {@snippet lang = c:
   * float laserXPos
   *}
   */
  public static final OfFloat laserXPos$layout() {
    return laserXPos$LAYOUT;
  }

  /**
   * Offset for field:
   * {@snippet lang = c:
   * float laserXPos
   *}
   */
  public static final long laserXPos$offset() {
    return laserXPos$OFFSET;
  }

  /**
   * Getter for field:
   * {@snippet lang = c:
   * float laserXPos
   *}
   */
  public static float laserXPos(MemorySegment struct) {
    return struct.get(laserXPos$LAYOUT, laserXPos$OFFSET);
  }

  /**
   * Setter for field:
   * {@snippet lang = c:
   * float laserXPos
   *}
   */
  public static void laserXPos(MemorySegment struct, float fieldValue) {
    struct.set(laserXPos$LAYOUT, laserXPos$OFFSET, fieldValue);
  }

  /**
   * Layout for field:
   * {@snippet lang = c:
   * float laserYPos
   *}
   */
  public static final OfFloat laserYPos$layout() {
    return laserYPos$LAYOUT;
  }

  /**
   * Offset for field:
   * {@snippet lang = c:
   * float laserYPos
   *}
   */
  public static final long laserYPos$offset() {
    return laserYPos$OFFSET;
  }

  /**
   * Getter for field:
   * {@snippet lang = c:
   * float laserYPos
   *}
   */
  public static float laserYPos(MemorySegment struct) {
    return struct.get(laserYPos$LAYOUT, laserYPos$OFFSET);
  }

  /**
   * Setter for field:
   * {@snippet lang = c:
   * float laserYPos
   *}
   */
  public static void laserYPos(MemorySegment struct, float fieldValue) {
    struct.set(laserYPos$LAYOUT, laserYPos$OFFSET, fieldValue);
  }

  /**
   * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}. The
   * returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
   */
  public static MemorySegment asSlice(MemorySegment array, long index) {
    return array.asSlice(layout().byteSize() * index);
  }

  /**
   * The size (in bytes) of this struct
   */
  public static long sizeof() {
    return layout().byteSize();
  }

  /**
   * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
   */
  public static MemorySegment allocate(SegmentAllocator allocator) {
    return allocator.allocate(layout());
  }

  /**
   * Allocate an array of size {@code elementCount} using {@code allocator}. The returned segment
   * has size {@code elementCount * layout().byteSize()}.
   */
  public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
    return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
  }

  /**
   * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any). The
   * returned segment has size {@code layout().byteSize()}
   */
  public static MemorySegment reinterpret(MemorySegment addr, Arena arena,
      Consumer<MemorySegment> cleanup) {
    return reinterpret(addr, 1, arena, cleanup);
  }

  /**
   * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any). The
   * returned segment has size {@code elementCount * layout().byteSize()}
   */
  public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena,
      Consumer<MemorySegment> cleanup) {
    return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
  }
}

