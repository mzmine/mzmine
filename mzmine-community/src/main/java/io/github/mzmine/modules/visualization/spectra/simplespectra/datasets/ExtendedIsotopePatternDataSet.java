/*
 * Copyright (c) 2004-2022 The MZmine Development Team
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.github.mzmine.modules.visualization.spectra.simplespectra.datasets;

import java.util.ArrayList;
import java.util.List;
import org.jfree.data.xy.IntervalXYDelegate;
import org.jfree.data.xy.XYBarDataset;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import io.github.msdk.MSDKRuntimeException;
import io.github.mzmine.datamodel.IsotopePattern;
import io.github.mzmine.datamodel.impl.SimpleIsotopePattern;

/**
 *
 * Dataset that can contain an SimpleIsotopePattern and convert it so it can be accessed by an bar
 * renderer. This also contains the description of the datapoints so they can be displayed as a
 * tooltip in the preview chart. The tooltips can be generated by SpectraToolTipGenerator.
 * Furthermore, a minimum intensity is specified and the peaks are sorted into two different
 * XYSeries to allow a color differentiation if the relative intensities are above or below the
 * given threshold.
 *
 * @author Steffen Heuckeroth steffen.heuckeroth@gmx.de / s_heuc03@uni-muenster.de
 *
 */
public class ExtendedIsotopePatternDataSet extends XYSeriesCollection {
  /**
   *
   */
  private static final long serialVersionUID = 1L;
  private SimpleIsotopePattern pattern;
  private double minIntensity;
  private XYSeries above;
  private XYSeries below;

  private double width;
  private List<String> descrBelow, descrAbove;
  private IntervalXYDelegate intervalDelegate;

  private enum AB {
    ABOVE, BELOW
  };

  Assignment assignment[];

  private class Assignment {
    AB ab;
    private int id;
  }

  /**
   *
   * @param pattern SimpleIsotopePattern to generate the dataset from
   * @param minIntensity minimum intensity (0.0-1.0) threshold for color differentiation
   * @param width Width of the datapoints to be displayed. Used for merging the peaks.
   */
  public ExtendedIsotopePatternDataSet(SimpleIsotopePattern pattern, double minIntensity,
      double width) {
    // super(pattern.getDescription(), pattern.getDataPoints());
    this.pattern = pattern;
    this.setMinIntensity(minIntensity);
    above = new XYSeries("Above minimum intensity");
    below = new XYSeries("Below minimum intensity");
    descrBelow = new ArrayList<String>();
    descrAbove = new ArrayList<String>();



    assignment = new Assignment[pattern.getNumberOfDataPoints()];
    for (int i = 0; i < assignment.length; i++)
      assignment[i] = new Assignment();

    for (int i = 0; i < pattern.getNumberOfDataPoints(); i++) {
      if (pattern.getIntensityValue(i) < minIntensity) {
        assignment[i].ab = AB.BELOW;
        assignment[i].id = i;
        below.add(pattern.getMzValue(i), pattern.getIntensityValue(i));
        descrBelow.add(pattern.getIsotopeComposition(i));
      } else {
        assignment[i].ab = AB.ABOVE;
        assignment[i].id = i;
        above.add(pattern.getMzValue(i), pattern.getIntensityValue(i));
        descrAbove.add(pattern.getIsotopeComposition(i));
      }
    }

    this.intervalDelegate = new IntervalXYDelegate(this);
    this.intervalDelegate.setFixedIntervalWidth(width);
    super.addSeries(above);
    super.addSeries(below);
  }
  int allDataPoints=0;
  int counter =0;
  public ExtendedIsotopePatternDataSet(SimpleIsotopePattern [] patterns, double minIntensity,
      double width) {
    // super(pattern.getDescription(), pattern.getDataPoints());
    above = new XYSeries("Above minimum intensity");
    below = new XYSeries("Below minimum intensity");
    descrBelow = new ArrayList<String>();
    descrAbove = new ArrayList<String>();
    for (SimpleIsotopePattern pattern:patterns ) {
      this.pattern =pattern;
      this.setMinIntensity(minIntensity);
      allDataPoints+=pattern.getNumberOfDataPoints();
    }
    assignment = new Assignment[allDataPoints];
    for (int i = 0; i < assignment.length; i++) {
      assignment[i] = new Assignment();
    }
    for (SimpleIsotopePattern pattern:patterns ) {
      for (int i = 0; i < pattern.getNumberOfDataPoints(); i++) {
        if (pattern.getIntensityValue(i) < minIntensity) {
          assignment[counter].ab = AB.BELOW;
          assignment[counter].id = counter;
          below.add(pattern.getMzValue(i), pattern.getIntensityValue(i));
          descrBelow.add(pattern.getIsotopeComposition(i));
        } else {
          assignment[counter].ab = AB.ABOVE;
          assignment[counter].id = counter;
          above.add(pattern.getMzValue(i), pattern.getIntensityValue(i));
          descrAbove.add(pattern.getIsotopeComposition(i));
        }
        counter+=1;
      }
    }

    this.intervalDelegate = new IntervalXYDelegate(this);
    this.intervalDelegate.setFixedIntervalWidth(width);
    super.addSeries(above);
    super.addSeries(below);
  }

  public String getItemDescription(int series, int item) {
    if (series == 0 && item < descrAbove.size())
      return descrAbove.get(item);
    if (series == 1 && item < descrBelow.size())
      return descrBelow.get(item);

    return "Invalid series/index";

  }

  // the next two methods are not needed yet but might come in handy in the
  // future
  public int getSeriesDpIndex(int peakIndex) throws MSDKRuntimeException {
    if (peakIndex >= pattern.getNumberOfDataPoints())
      throw new MSDKRuntimeException("Index out of bounds.");
    return assignment[peakIndex].id;
  }

  public AB getSeriesAB(int peakIndex) throws MSDKRuntimeException {
    if (peakIndex >= pattern.getNumberOfDataPoints())
      throw new MSDKRuntimeException("Index out of bounds.");
    return assignment[peakIndex].ab;
  }

  public IsotopePattern getIsotopePattern() {
    return pattern;
  }

  public XYBarDataset getBarDataset(double mergeWidth) {

    return new XYBarDataset(this, mergeWidth);
  }

  public double getWidth() {
    return width;
  }

  public void setWidth(double width) {
    this.width = width;
    this.intervalDelegate.setFixedIntervalWidth(width);
  }

  /**
   * By redefining this, the pattern is displayed as an actual bar instead of a line
   */
  @Override
  public double getStartXValue(int series, int item) {
    return intervalDelegate.getStartXValue(series, item);
  }

  /**
   * By redefining this, the pattern is displayed as an actual bar instead of a line
   */
  @Override
  public double getEndXValue(int series, int item) {
    return intervalDelegate.getEndXValue(series, item);
  }

  public double getMinIntensity() {
    return minIntensity;
  }

  public void setMinIntensity(double minIntensity) {
    this.minIntensity = minIntensity;
  }
}
